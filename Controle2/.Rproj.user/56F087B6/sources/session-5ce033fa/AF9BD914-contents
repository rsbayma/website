```{r include=FALSE,echo=FALSE}
library(reticulate)
```


# Análise de sistemas com espaço de estados

Dada uma entrada $u(t)$ e uma condição inicial dos estados $\mathbf{x}(0)$, podemos resolver a equação diferencial (matricial) dos estados e determinar a saída do sistema. 

Isso pode ser feito com a transformada de Laplace da mesma forma como se fosse uma equação escalar. Devemos apenas atentar que para uma equação matricial, a divisão é substituída pela multiplicação por matriz inversa. 

\begin{aligned}
    \mathbf{\dot{x}} &= \mathbf{Ax+B}u\\
    \mathcal{L}\{\mathbf{\dot{x}}\} &= \mathcal{L}\{\mathbf{Ax+B}u\}\\
    s\mathbf{X}(s)-\mathbf{x}(0) &= \mathbf{AX}(s)+\mathbf{B}U(s)\\
    s\mathbf{X}(s)-\mathbf{AX}(s)&=\mathbf{x}(0)+\mathbf{B}U(s)\\
    (s\mathbf{I-A})\mathbf{X(s)} &= \mathbf{x}(0)+\mathbf{B}U(s)\\
    \mathbf{X(s)} &= (s\mathbf{I-A})^{-1}\mathbf{x}(0)+(s\mathbf{I-A})^{-1}\mathbf{B}U(s)\\
\end{aligned}


O termo $(s\mathbf{I-A})^{-1}\mathbf{x}(0)$ é a resposta de entrada nula, devido sua independência da função de entrada.

O termo $(s\mathbf{I-A})^{-1}\mathbf{B}U(s)$ é a resposta de estado nulo, devido sua independência das condições iniciais.

Para determinar os estados no domínio do tempo $\mathbf{x}(t)$ bastaria tirar a transformada inversa. Assim teríamos a resposta de cada um dos estados em função do tempo.

## Sinal de saída e função de transferência

Olhando agora o sinal de saída:
\begin{aligned}
    y &= \mathbf{Cx} + Du\\
    Y(s) &= \mathbf{CX(s)} + DU(s)
\end{aligned}

Substituindo o que encontramos para $\mathbf{X}(s)$:
\begin{aligned}
    Y(s) &= \mathbf{C}(s\mathbf{I-A})^{-1}\mathbf{x}(0)+\mathbf{C}(s\mathbf{I-A})^{-1}\mathbf{B}U(s) + DU(s)
\end{aligned}

Colocando $U(s)$ em evidência agora:
\begin{aligned}
    Y(s) &= \mathbf{C}(s\mathbf{I-A})^{-1}\mathbf{x}(0)+\left[\mathbf{C}(s\mathbf{I-A})^{-1}\mathbf{B} + D\right]U(s)
\end{aligned}

Quando as condições iniciais são nulas $\mathbf{x}(0)=\mathbf{0}$, o termo que sobra é um escalar:
\begin{aligned}
    Y(s) &= \left[\mathbf{C}(s\mathbf{I-A})^{-1}\mathbf{B} + D\right]U(s)\\
    \frac{Y(s)}{U(s)} &= \mathbf{C}(s\mathbf{I-A})^{-1}\mathbf{B} + D
\end{aligned}

Reconhecemos a última equação como a função de transferência do sistema definida em termos das matrizes da representação de espaço de estados.

## Pólos de um sistema no espaço de estados (Autovalores)

Na equação da função de transferência, o termo principal é $(s\mathbf{I-A})^{-1}$. Sabemos que a inversa de qualquer matriz pode ser descrita como sua adjunta divido pelo seu determinante. O que vai sobrar no denominador da função de transferência, portanto, é $\det (s\mathbf{I-A})$.

Sabemos que os pólos são as raízes do denominador de uma função de transferência. Ora, se o denominador é dado pelo determinante acima, então os pólos do sistema são dados pelas soluções da equação:
\begin{aligned}
\det (s\mathbf{I-A}) = 0
\end{aligned}

Os valores de $s$ que satisfazem essa equação são chamados em álgebra linear de **autovalores da matriz** e de desempenham um papel importante em vários problemas de Engenharia. 

Em Python vc pode calcular os autovalores do sistema usando a funçao "pole()" da biblioteca *control*, ou usar a biblioteca *linalg* do NumPy para resolver o problema de autovalor diretamente na matriz de estados do sistema. Note, porém, que a função "eig()" do NumPy devolve não apenas os autovalores, mas também os [autovetores](https://pt.wikipedia.org/wiki/Autovalores_e_autovetores) associados também.

```{r, echo=FALSE, out.width="100%", fig.aligned = 'center'}
knitr::include_graphics("./figs/Ex7.12.svg")
```

Solução manual (você precisa saber fazer manualmente *pelo menos* os casos de ordem 2):

\begin{aligned}
    s\mathbf{I-A} &= s\left[\begin{array}{cc}1 & 0\\0 & 1\end{array}\right]-\left[\begin{array}{cc}-7 & -12\\1 & 0\end{array}\right]\\
    &= \left[\begin{array}{cc}s+7 & 12\\-1 & s\end{array}\right]
\end{aligned}


A inversa da matriz é:
\begin{aligned}
    (s\mathbf{I-A})^{-1} &= \frac{\left[\begin{array}{cc}s & -12\\1 & s+7\end{array}\right]}{s(s+7)+12}
\end{aligned}


Faz-se agora o produto pela esquerda:
\begin{aligned}
    \mathbf{C}(s\mathbf{I-A})^{-1} &= \frac{\left[\begin{array}{cc}1 & 2\end{array}\right]\left[\begin{array}{cc}s & -12\\1 & s+7\end{array}\right]}{s(s+7)+12}\\
    &= \frac{\left[\begin{array}{cc}s+2 & 2s+2\end{array}\right]}{s^2+7s+12}
\end{aligned}

E o resultado com o produto pela direita:
\begin{aligned}
    \mathbf{C}(s\mathbf{I-A})^{-1}\mathbf{B} &= \frac{\left[\begin{array}{cc}s+2 & 2s+2\end{array}\right]\left[\begin{array}{c}1 \\ 0\end{array}\right]}{s^2+7s+12}\\
    & = \frac{s+2}{s^2+7s+12}
\end{aligned}

**Exercício**: Calcule manualmente e confira sua resposta com Python, a função de transferência do sistema

\begin{aligned}
\dot{\mathbf{x}} &= \left[\begin{array}{cc}-1 & 7\\ 9 & 0\end{array}\right]\mathbf{x} + \left[\begin{array}{cc} 5 \\ -3\end{array}\right]u\\
y &= \left[\begin{array}{cc}3 & 2\end{array}\right]\mathbf{x} 
\end{aligned}

## Zeros do sistema

Na descrição entrada-saída (função de transferência) de um sistema, definimos zeros de uma forma bem matemática: são as raízes do numerador.

No entanto, os zeros possuem uma definição um pouco mais física. São chamados zeros os modos (exponenciais) que, se colocados na entrada do sistema, produzem uma saída identicamente nula. Isso permite estabelecer as expressões que definem os zeros do sistema em função das matrizes de espaço de estados.

Para achar os zeros, basta resolver a equação polinomial:
\begin{aligned}
\det\,\left[\begin{array}{cc}s\mathbf{I-A} & -\mathbf{B}\\ \mathbf{C} & D\end{array}\right]=0 
\end{aligned}

```{r, echo=FALSE, out.width="100%", fig.aligned = 'center'}
knitr::include_graphics("./figs/Ex7.13.svg")
```

**Solução**: Precisamos montar a matriz. No caso, já calculamos $s\mathbf{I-A}$ no exemplo anterior, então basta concatenar as demais:
\begin{aligned}
    s\mathbf{I-A} &= \left[\begin{array}{cc}s+7 & 12\\-1 & s\end{array}\right]\\
    \Rightarrow \left[\begin{array}{ccc}s\mathbf{I-A} & -\mathbf{B}\\ \mathbf{C} & D\end{array}\right]&=
    \left[\begin{array}{ccc}s+7 & 12 & -1\\-1 & s & 0\\ 1 & 2 & 0 \end{array}\right]
\end{aligned}

Basta agora calcular o determinante.
\begin{aligned}
    \det \left[\begin{array}{ccc}s+7 & 12 & 1\\-1 & s & 0\\ 1 & 2 & 0 \end{array}\right] &= 
    \det \left[\begin{array}{cc}-1 & s \\ 1 & 2 \end{array}\right] = -2-s 
\end{aligned}

Igualando a zero, temos:
\begin{aligned}
    -2-s =0 \Rightarrow s = -2
\end{aligned}

Em Python, a função "zero()" é capaz de determinar os zeros a partir da representação do sistema

## Estabilidade no espaço de estados

O conceito de estabilidade no espaço de estados é um pouco diferente do que aprendemos na representação entrada-saída.

A estabilidade é relativa a um ponto de equilíbrio do sistema.

Um sistema é estável se, dada uma condição inicial $\mathbf{x}(0)$ próxima do ponto de equilíbrio, o estado $\mathbf{x}(t)$ do sistema retorna para o ponto de equilíbrio inicial e ali permanece.

Um sistema linear possui apenas um ponto de equilíbrio, o vetor nulo $\mathbf{x}= \left[\begin{array}{cccc}0 & 0 & \ldots & 0\end{array}\right]$.

É fácil de verificar que esse é um ponto de equilíbrio. Dada a equação de estados
\begin{aligned}
    \mathbf{\dot{x}} &= \mathbf{Ax+B}u
\end{aligned}

vemos que se $u=0$ e se $\mathbf{x=0}$, então todo o lado direito se anula, o que implica que $\mathbf{\dot{x}=0}$. Ou seja, o sistema não evolui com o tempo, fica sempre no "mesmo lugar".

Um sistema linear será estável se, dada uma condição inicial diferente de zero do vetor de estados, o vetor $\mathbf{x}(t)$ voltar para zero em um determinado intervalo de tempo. 

Como já sabemos, o sistema é estável quando todos os seus pólos estão no semi-plano esquerdo (SPE). Como no espaço de estados os pólos são autovalores da matriz de estados $\mathbf{A}$, então o sistema será estável se todos esses autovalores tiverem parte real estritamente negativa. 

Isso garante que quando passar um longo tempo, isto é, $t\rightarrow \infty$, os estados tenderão a zero, ou seja $\mathbf{x}(t) \rightarrow \mathbf{0}$. Isso é chamado também de **estabilidade assintótica**.

**Exemplo:** verifique se o sistema abaixo é estável

\begin{aligned}
    \dot{\mathbf{x}}= \left[\begin{array}{cc}0 &1\\ -3 & -7\end{array}\right]\mathbf{x} +
    \left[\begin{array}{c}1\\ 2\end{array}\right]u
\end{aligned}

```{python, echo=FALSE, include=FALSE}
from sympy import *

s = symbols('s')
A = ImmutableMatrix([[0,1],[-3, -7]])
sI = s*eye(2)
pA = det(s*eye(2)-A)
sIstr = latex(sI)
sIA = latex(sI-A)
I = latex(eye(2))
Astr = latex(A)
pAstr = latex(pA)
r = solve(pA)
r0str = latex(r[0].evalf(4))
r1str = latex(r[1].evalf(4))
```

Solução manual:
\begin{align}
  s\mathbf{I-A} &=  s `r py$I` -  `r py$Astr` \\
  &=  `r py$sIstr` - `r py$Astr` \\
  &=  `r py$sIA` 
\end{align}

Logo:
\begin{align}
  |s\mathbf{I-A}| &= \left| `r py$sIA` \right|\\
  &= `r py$pAstr`
\end{align}

Igualando o polinômio característico a zero temos as raízes $s = `r py$r0str`$ e $s = `r py$r1str`$. Ambas possuem parte real negativa, logo o sistema é estável. 

Usando Python:

```{python}
import numpy as np

A = np.array([[0,1],[-3, -7]])
np.linalg.eig(A)[0]

```

A função "eig" do submódulo "numpy.linalg" calcula os autovalores e autovetores de uma matriz quadrada. O primeiro argumento de saída (por isso o "[0]") fornece os autovalores, que neste caso correspondem ao que foi calculado manualmente. 
