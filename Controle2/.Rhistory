D = np.array([[0]])
xi = 0.707
wn = 1/1.15
p = -xi*wn+1j*wn*np.sqrt(1-xi**2)
polos_dom = np.array([[p, np.conjugate(p)]])
polos_extras = np.array([[np.real(p)*4]*3])
polos_mf = np.block([polos_dom,polos_extras])
K = ct.acker(A,B,polos_mf[0,:])
N = 1/(C @ np.linalg.inv(-A+B@K) @ B)
kk = ImmutableMatrix(K)
K_str = latex(kk.evalf(4))
Amf = A - B@K
Bmf = B@N
Cmf = C
Dmf = np.array([[0]])
# Sistema
sis = ct.ss(Amf,Bmf,Cmf,Dmf)
# Simulação
t,y = ct.step_response(sis,7)
plt.plot(t,y)
plt.grid()
plt.xlabel('Tempo (seg)')
plt.ylabel('Saída')
plt.legend('y')
plt.show()
tab = ct.damp(sis)
sis.zeros()
print(max(y))
quit
knitr::include_graphics("./figs/Ex7.17.svg")
reticulate::repl_python()
# Imports
import control as ct
import numpy as np
z0 = 2.
# Declaração das matrizes e do sistema
A = np.array([[-7,1],[-12,0]])
B = np.array([[1],[-z0]])
C = np.array([[1,0]])
D = np.array([[0]])
sys = ct.ss(A,B,C,D)
# Pólos desejados
xi = 0.5
wn = 2
polo = wn*(-xi+1j*np.sqrt(1-xi**2))
# Alocação de polos
K = ct.acker(A,B,[polo, np.conj(polo)])
K_str = latex(ImmutableMatrix(K))
import sympy as sp
s = sp.symbols('s')
w0 = sp.symbols(r'\omega_0')
l1,l2 = sp.symbols(['l_1','l_2'])
A = sp.Matrix([[0,1],[-w0**2,0]])
C = sp.Matrix([1,0]).T
L = sp.Matrix([[l1],[l2]])
A_str = sp.latex(A)
C_str = sp.latex(C)
L_str = sp.latex(L)
#Poliômio do observador
eq1 = '&= s' + sp.latex(sp.eye(2))  # sI
eq1 += '-' + sp.latex(A) + '+' + sp.latex(L) + sp.latex(C) +'='
eq2 = '&= ' + sp.latex(s*sp.eye(2)) + '-'  + sp.latex(A) + '+' + sp.latex(L@C) + ' = '
eq3 = '&= ' + sp.latex(s*sp.eye(2)-A+L@C)
# Polinômio do observador (A-LC)
p_obsv = sp.det(s*sp.eye(2)-A+L@C)
p_obsv_str = sp.latex(p_obsv)
# Polinômio desejado
p_desejado = sp.expand((s+10*w0)**2)
p_desejado_str = sp.latex(p_desejado)
# Igualando termo a termo
eq = [sp.Eq(p_obsv.coeff(s,n),p_desejado.coeff(s,n)) for n in (0,1)]
eq4 = sp.latex(eq[0])
eq5 = sp.latex(eq[1])
sol = sp.solve(eq,L)
sol_str = r'\mathbf{L} = ' + sp.latex(L.subs(sol))
# Imports
import control as ct
# Declara as matrizes
w0=1
A = np.array([[0,1],[-w0**2,0]])
C = np.array([[1,0]])
# Posiciona os polos
L = ct.acker(A=A.T,B=C.T,poles=[-10*w0,-10*w0]).T
L_str = sp.latex(ImmutableMatrix(L))
# Imports
import control as ct
import numpy as np
A = np.array([[0,1],[0,0]])
B = np.array([[0],[1]])
C = np.array([[1,0]])
D = np.array([[0]])
sys = ct.ss(A,B,C,D)
Co= ct.ctrb(A,B)
Co_str = latex(ImmutableMatrix(Co))
det_Co_str = latex(np.linalg.det(Co))
Ob= ct.obsv(A,C)
Ob_str = latex(ImmutableMatrix(Ob))
det_Ob_str = latex(np.linalg.det(Ob))
xi = 0.707
wn = 1
p = wn*(-xi+1j*np.sqrt(1-xi**2))
pr = [p, np.conj(p)]
K = ct.acker(A,B,pr)
K_str = latex(ImmutableMatrix(K))
xi = 0.5
wn = 5
p = wn*(-xi+1j*np.sqrt(1-xi**2))
po = [p, np.conj(p)]
L = ct.acker(A.T,C.T,po).T
L_str = latex(ImmutableMatrix(L))
comp = ct.ss(A-B@K-L@C, L, -K,0)
Qs = ct.tf(comp)
numQ = latex(Poly(Qs.num[0][0].round(4),s).as_expr())
denQ = latex(Poly(Qs.den[0][0].round(4),s).as_expr())
Qs_str = r'\frac{' + numQ + '}{' + denQ + '}'
Amf = np.block([[A, -B@K],[L@C, A-B@K-L@C]])
Bmf = np.block([[B],[B]])
Cmf = np.block([[C, np.zeros(C.shape)]])
N = 1/(Cmf @ np.linalg.inv(-Amf) @ Bmf)
Bmf = Bmf @ N
sis_mf = ct.ss(Amf,Bmf,Cmf, 0)
out = ct.step_response(sis_mf)
plt.plot(out.t,out.outputs)
plt.grid()
plt.xlabel('Tempo (seg)')
plt.ylabel('Saída')
plt.legend('y')
plt.show()
quit
knitr::include_graphics("./figs/controleIntegral.svg")
reticulate::repl_python()
# Imports
import numpy as np
import control as ct
import sympy as sp
A = np.array([[-3,2],[10,0]])
B = np.array([[0],[1]])
C = np.array([[1,0]])
D = np.array([[0]])
A_str = sp.latex(sp.ImmutableMatrix(A))
B_str = sp.latex(sp.ImmutableMatrix(B))
C_str = sp.latex(sp.ImmutableMatrix(C))
Aa = np.block([[A, np.zeros([2,1])],[-C, 0]])
Ba = np.block([[B],[0]])
Aa_str = sp.latex(sp.ImmutableMatrix(Aa))
Ba_str = sp.latex(sp.ImmutableMatrix(Ba))
xi = 0.7
wn = 2
# Polos de MF desejados
pr = wn*(-xi+1j*np.sqrt(1-xi**2))
re_s = sp.latex(round(np.real(pr),4))
im_s = sp.latex(round(np.imag(pr),4))
p = [pr, np.conj(pr), -5*abs(pr)]
Ka = ct.acker(Aa,Ba,p)
Ka_str = sp.latex(sp.ImmutableMatrix(Ka).evalf(4))
Ki = Ka[0,-1]
Ki_str = sp.latex(Ki)
K = Ka[0,0:-1]
K_str = sp.latex(sp.ImmutableDenseMatrix(K))
po = [10*pr, 10*np.conj(pr)]
L = ct.acker(A.T, C.T, po).T
L_str = sp.latex(sp.ImmutableMatrix(L))
Al = np.block([[A,np.zeros((n,1))],[np.zeros((1,n+1))]])
n = 2
Al = np.block([[A,np.zeros((n,1))],[np.zeros((1,n+1))]])
Ac = np.block([[A-B@K-L@C, -B@Ki], np.zeros((1,3))])
A-B@K-L@C
B@K
B
K
K = Ka[:,0:-2]
K
K = Ka[:,0:-1]
K
Ka_str = sp.latex(sp.ImmutableMatrix(Ka).evalf(4))
Ki = Ka[0,-1]
Ki_str = sp.latex(Ki)
K = Ka[:,0:-1]
K_str = sp.latex(sp.ImmutableDenseMatrix(K))
Ka_str = sp.latex(sp.ImmutableMatrix(Ka).evalf(4))
Ki = Ka[0,-1]
Ki_str = sp.latex(Ki)
K = Ka[:,0:-1]
K_str = sp.latex(sp.ImmutableDenseMatrix(K))
Ac = np.block([[A-B@K-L@C, -B@Ki], np.zeros((1,3))])
B1 = np.block([[L1],[-1]])
B2 = np.block([[np.zeros(2,1)],[-1]])
Cc = np.block([-K, Ki])
D1 = 0
D2 = 0
Ac = np.block([[A-B@K-L@C, -B@Ki], np.zeros((1,3))])
B@K
L@C
A-B@K-L@C
B@Ki
Ac = np.block([[A-B@K-L@C, -B*Ki], np.zeros((1,3))])
Ki
B*Ki
Ac = np.block([[A-B@K-L@C, -B*Ki], [np.zeros((1,3))])
Ac = np.block([[A-B@K-L@C, -B*Ki], [np.zeros((1,3))])
Ac = np.block([[A-B@K-L@C, -B*Ki], [np.zeros((1,3))]])
Ac
B1 = np.block([[L1],[-1]])
B1 = np.block([[L],[-1]])
B2 = np.block([[np.zeros(2,1)],[-1]])
B2 = np.block([[np.zeros((2,1))],[-1]])
Cc = np.block([-K, Ki])
G = ct.tf(10,[1,3,2])
G
print(G)
ct.ss(G)
sis = ct.ss(G)
sis.A
sis.B
sis.C
G = ct.tf(10, np.poly([-1, -2]))
MF = ct.series(C2,ct.feedback(G,C1,1))
tabela = ct.damp(MF)
MF.zeros()
quit
library(reticulate)
knitr::include_graphics("./figs/Ex7.15.svg")
reticulate::repl_python()
from sympy import *
k1, k2, w0 = symbols(r'k_1 k_2 \omega_0')
K = ImmutableMatrix([[k1, k2]])
A = ImmutableMatrix([[0, 1],[-w0**2, 0]])
B = ImmutableMatrix([[0],[1]])
Am = A-B@K
Am_str = latex(Am)
s = symbols('s')
mf = Am.charpoly(s)
mf_str = latex(mf.as_expr())
alfa = (s+2*w0)**2
alfa_exp = alfa.as_expr().expand()
alfa_str = latex(alfa_exp)
quit
knitr::include_graphics("./figs/Fig7.13.svg")
knitr::include_graphics("./figs/Ex7.16.svg")
reticulate::repl_python()
Con = ImmutableMatrix(BlockMatrix([B,A@B]))
aa = 4*w0**2*eye(2)+4*w0*A+A@A
Con_str = latex(Con)
aa_str = latex(aa)
iCon = Con.inverse()
iCon_str = latex(iCon)
K = ImmutableMatrix([[0,1]])@ iCon @ aa
K_str = latex(K)
import control as ct
import numpy as np
w0 = 1
w0 = symbols(r'\omega_0')
A = ImmutableMatrix([[0, 1],[-w0**2, 0]])
B = ImmutableMatrix([[0],[1]])
C = ImmutableMatrix([[1,0]])
K = ImmutableMatrix([[3*w0**2,4*w0]])
X = (-A+B@K)
iX = X.inverse()
iN = (C@iX@B)[0]
N = 1/iN
X_str = latex(X)
iX_str = latex(iX)
iN_str = latex(iN)
N_str = latex(N)
import control as ct
import numpy as np
w0 = 1
A = np.array([[0, 1],[-w0**2, 0]])
B = np.array([[0],[1]])
C = np.array([[1,0]])
polos = [-2*w0, -2*w0]
K = ct.acker(A,B, polos)
N = 1/(C @ np.linalg.inv(-A+B@K) @ B)
Amf = A - B@K
Bmf = B@N
Cmf = C
Dmf = np.array([[0]])
# Sistema
sis = ct.ss(Amf,Bmf,Cmf,Dmf)
tab = ct.damp(sis)
ct.zeros(sis)
t,y = ct.step_response(sis,7)
import matplotlib.pyplot as plt
plt.plot(t,y)
plt.grid()
plt.xlabel('Tempo (seg)')
plt.ylabel('Saída')
plt.legend('y')
plt.show()
# Imports
import control as ct
import numpy as np
# Sistema
A = np.array([  [0, 2, 0, 0, 0],
[-.1, -.35, .1, .1, .75],
[0, 0, 0, 2, 0],
[.4, .4, -.4, -1.4, 0],
[0, -.03, 0, 0, -1]     ],dtype=float)
B = np.array([[0],[0],[0],[0],[1]])
C = np.array([[1,0,0,0,0]])
D = np.array([[0]])
xi = 0.707
wn = 1/1.15
p = -xi*wn+1j*wn*np.sqrt(1-xi**2)
polos_dom = np.array([[p, np.conjugate(p)]])
polos_extras = np.array([[np.real(p)*4]*3])
polos_mf = np.block([polos_dom,polos_extras])
K = ct.acker(A,B,polos_mf[0,:])
N = 1/(C @ np.linalg.inv(-A+B@K) @ B)
kk = ImmutableMatrix(K)
K_str = latex(kk.evalf(4))
Amf = A - B@K
Bmf = B@N
Cmf = C
Dmf = np.array([[0]])
# Sistema
sis = ct.ss(Amf,Bmf,Cmf,Dmf)
# Simulação
t,y = ct.step_response(sis,7)
plt.plot(t,y)
plt.grid()
plt.xlabel('Tempo (seg)')
plt.ylabel('Saída')
plt.legend('y')
plt.show()
tab = ct.damp(sis)
sis.zeros()
print(max(y))
quit
knitr::include_graphics("./figs/Ex7.17.svg")
reticulate::repl_python()
# Imports
import control as ct
import numpy as np
z0 = 2.
# Declaração das matrizes e do sistema
A = np.array([[-7,1],[-12,0]])
B = np.array([[1],[-z0]])
C = np.array([[1,0]])
D = np.array([[0]])
sys = ct.ss(A,B,C,D)
# Pólos desejados
xi = 0.5
wn = 2
polo = wn*(-xi+1j*np.sqrt(1-xi**2))
# Alocação de polos
K = ct.acker(A,B,[polo, np.conj(polo)])
K_str = latex(ImmutableMatrix(K))
import sympy as sp
s = sp.symbols('s')
w0 = sp.symbols(r'\omega_0')
l1,l2 = sp.symbols(['l_1','l_2'])
A = sp.Matrix([[0,1],[-w0**2,0]])
C = sp.Matrix([1,0]).T
L = sp.Matrix([[l1],[l2]])
A_str = sp.latex(A)
C_str = sp.latex(C)
L_str = sp.latex(L)
#Poliômio do observador
eq1 = '&= s' + sp.latex(sp.eye(2))  # sI
eq1 += '-' + sp.latex(A) + '+' + sp.latex(L) + sp.latex(C) +'='
eq2 = '&= ' + sp.latex(s*sp.eye(2)) + '-'  + sp.latex(A) + '+' + sp.latex(L@C) + ' = '
eq3 = '&= ' + sp.latex(s*sp.eye(2)-A+L@C)
# Polinômio do observador (A-LC)
p_obsv = sp.det(s*sp.eye(2)-A+L@C)
p_obsv_str = sp.latex(p_obsv)
# Polinômio desejado
p_desejado = sp.expand((s+10*w0)**2)
p_desejado_str = sp.latex(p_desejado)
# Igualando termo a termo
eq = [sp.Eq(p_obsv.coeff(s,n),p_desejado.coeff(s,n)) for n in (0,1)]
eq4 = sp.latex(eq[0])
eq5 = sp.latex(eq[1])
sol = sp.solve(eq,L)
sol_str = r'\mathbf{L} = ' + sp.latex(L.subs(sol))
# Imports
import control as ct
# Declara as matrizes
w0=1
A = np.array([[0,1],[-w0**2,0]])
C = np.array([[1,0]])
# Posiciona os polos
L = ct.acker(A=A.T,B=C.T,poles=[-10*w0,-10*w0]).T
L_str = sp.latex(ImmutableMatrix(L))
# Imports
import control as ct
import numpy as np
A = np.array([[0,1],[0,0]])
B = np.array([[0],[1]])
C = np.array([[1,0]])
D = np.array([[0]])
sys = ct.ss(A,B,C,D)
Co= ct.ctrb(A,B)
Co_str = latex(ImmutableMatrix(Co))
det_Co_str = latex(np.linalg.det(Co))
Ob= ct.obsv(A,C)
Ob_str = latex(ImmutableMatrix(Ob))
det_Ob_str = latex(np.linalg.det(Ob))
xi = 0.707
wn = 1
p = wn*(-xi+1j*np.sqrt(1-xi**2))
pr = [p, np.conj(p)]
K = ct.acker(A,B,pr)
K_str = latex(ImmutableMatrix(K))
xi = 0.5
wn = 5
p = wn*(-xi+1j*np.sqrt(1-xi**2))
po = [p, np.conj(p)]
L = ct.acker(A.T,C.T,po).T
L_str = latex(ImmutableMatrix(L))
comp = ct.ss(A-B@K-L@C, L, -K,0)
Qs = ct.tf(comp)
numQ = latex(Poly(Qs.num[0][0].round(4),s).as_expr())
denQ = latex(Poly(Qs.den[0][0].round(4),s).as_expr())
Qs_str = r'\frac{' + numQ + '}{' + denQ + '}'
Amf = np.block([[A, -B@K],[L@C, A-B@K-L@C]])
Bmf = np.block([[B],[B]])
Cmf = np.block([[C, np.zeros(C.shape)]])
N = 1/(Cmf @ np.linalg.inv(-Amf) @ Bmf)
Bmf = Bmf @ N
sis_mf = ct.ss(Amf,Bmf,Cmf, 0)
out = ct.step_response(sis_mf)
plt.plot(out.t,out.outputs)
plt.grid()
plt.xlabel('Tempo (seg)')
plt.ylabel('Saída')
plt.legend('y')
plt.show()
quit
knitr::include_graphics("./figs/controleIntegral.svg")
reticulate::repl_python()
# Imports
import numpy as np
import control as ct
import sympy as sp
A = np.array([[-3,-2],[1,0]])
B = np.array([[1],[0]])
C = np.array([[0,10]])
D = np.array([[0]])
A_str = sp.latex(sp.ImmutableMatrix(A))
B_str = sp.latex(sp.ImmutableMatrix(B))
C_str = sp.latex(sp.ImmutableMatrix(C))
Aa = np.block([[A, np.zeros([2,1])],[-C, 0]])
Ba = np.block([[B],[0]])
Aa_str = sp.latex(sp.ImmutableMatrix(Aa))
Ba_str = sp.latex(sp.ImmutableMatrix(Ba))
xi = 0.7
wn = 2
# Polos de MF desejados
pr = wn*(-xi+1j*np.sqrt(1-xi**2))
re_s = sp.latex(round(np.real(pr),4))
im_s = sp.latex(round(np.imag(pr),4))
p = [pr, np.conj(pr), -5*abs(pr)]
Ka = ct.acker(Aa,Ba,p)
Ka_str = sp.latex(sp.ImmutableMatrix(Ka).evalf(4))
Ki = Ka[0,-1]
Ki_str = sp.latex(Ki)
K = Ka[:,0:-1]
K_str = sp.latex(sp.ImmutableDenseMatrix(K))
po = [10*pr, 10*np.conj(pr)]
L = ct.acker(A.T, C.T, po).T
L_str = sp.latex(sp.ImmutableMatrix(L))
n = 2
Al = np.block([[A,np.zeros((n,1))],[np.zeros((1,n+1))]])
Bl = Ba
Cl = np.block([C,0])
L0 = np.block([[L],[0]])
L1 = np.block([[L],[-1]])
M = np.block([[np.zeros((n,1))],[1]])
Ac = np.block([[A-B@K-L@C, -B*Ki], [np.zeros((1,3))]])
B1 = np.block([[L],[-1]])
B2 = np.block([[np.zeros((2,1))],[-1]])
Cc = np.block([-K, -Ki])
D1 = np.array([[0]])
D2 = D1
Ac_str = sp.latex(sp.ImmutableMatrix(Ac))
Bc_str = sp.latex(sp.ImmutableMatrix(B1))
Cc_str = sp.latex(sp.ImmutableMatrix(Cc))
Dc_str = sp.latex(sp.ImmutableMatrix(D1))
C1 = ct.ss(Ac, B1, Cc, D1)
C1 = ct.tf(C1)
import sympy as sp
s = sp.symbols('s')
n1 = sp.Poly(C1.num[0][0],s).as_expr().evalf(5)
d1 = sp.Poly(C1.den[0][0],s).as_expr().evalf(5)
C1s = n1/d1
C1_str = sp.latex(C1s)
C2 = ct.ss(Ac, B2, Cc, D2)
C2 = ct.tf(C2)
n2 = sp.Poly(C2.num[0][0],s).as_expr().evalf(5)
d2 = sp.Poly(C2.den[0][0],s).as_expr().evalf(5)
C2s = n2/d2
C2_str = sp.latex(C2s)
C1.poles()
C1.zeros()
C2.zeros()
Amf = np.block([[A  ,  -B@Ka ] , [ L1@C ,  Al-Bl@Ka-L0@Cl ] ])
Bmf = np.block([[np.zeros(B.shape)],[M]])
Cmf = np.block([C, np.zeros([1,3])])
Dmf = 0
sis_mf = ct.ss(Amf,Bmf,Cmf,Dmf)
resp = ct.step_response(sis_mf)
plt.plot(resp.t, resp.outputs)
plt.grid()
plt.xlabel('Tempo (seg)')
plt.show()
tabela = ct.damp(sis_mf)
sis_mf.zeros()
G = ct.tf(10, np.poly([-1, -2]))
MF = ct.series(C2,ct.feedback(G,C1,1))
tabela = ct.damp(MF)
MF.zeros()
