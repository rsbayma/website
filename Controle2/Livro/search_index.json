[["index.html", "Sistemas de Controle II (EL180) Capítulo 1 Apresentação 1.1 Objetivos 1.2 Avaliação:", " Sistemas de Controle II (EL180) Rafael Suzuki Bayma 2024-03-26 Capítulo 1 Apresentação Curso de Sistemas de Controle II - Faculdade de Engenharia Elétrica, Campus Tucuruí. Versão: 2024.2 1.1 Objetivos Objetivo principal do curso é introduzir técnicas de modelagem, análise e projeto de sistemas de controle usando duas abordagens principais: espaço de estados e modelos de sinais e sistemas digitaisl. Carga horária: 60 horas O curso é predominantemente teórico com aplicações computacionais. Aplicações práticas em laboratório poderão ocorrer mediante disponibilidade de equipamento. Pré-requisitos: Análise de Sistemas Lineares, Sistemas de Controle I. Recomendado: boa compreensão de equações diferenciais, sinais e sistemas, mecânica clássica, Circuitos Elétricos I, amplificadores operacionais, Python simbólico e numérico, linguagem R (apenas para gerar trabalhos de melhor qualidade). 1.2 Avaliação: Estimativa de 2 trabalhos divididos em 2 partes cada. Trabalho 1 - espaço de estados. Parte 1: exame escrito com resolução de problemas básicos de baixa ordem (3a no máximo); trabalho presencial realizado em sala, individual, com consulta. Parte 2: projeto computacional resolvido em Python de um problema mais complexo, com auxílio das bibliotecas relevantes e simulação. Objetivo é fazer o projeto, simular e analisar o resultado. Trabalho 2 - sistemas digitais. Partes seguindo o mesmo roteiro do trabalho 1, exceto agora sobre sistemas digitais. Trabalho final - opcional, versando sobre toda a matéria. Destinado apenas aqueles que não alcançaram média ou que necessitarem de 2a chamada. A parte computacional deve ser feita toda em Python. Os projetos devem ser entregues no formato de um relatório/dashboard em arquivo PDF ou HTML contendo os resultados e a análise. Outros formatos não serão aceitos por questões de organização e portabilidade. Uma correção dos erros em cada trabalho poderá ser apresentada, caso autorizada, com uma penalidade na pontuação final (a definir em cada avaliação). Válido apenas aos alunos que fizeram a primeira entrega. Vedado participar da correção ao aluno que não entregou o trabalho. A nota final é a média simples das duas maiores notas. "],["introdução-às-técnicas-de-espaço-de-estados..html", "Capítulo 2 Introdução às técnicas de espaço de estados. 2.1 O que é espaço de estados? 2.2 O que é estado? 2.3 Sistemas LIT SISO 2.4 Representação matricial 2.5 Sistemas LIT MIMO 2.6 Sistemas não-lineares 2.7 Equilíbrio 2.8 Linearização", " Capítulo 2 Introdução às técnicas de espaço de estados. Os métodos de espaço de estados são importantes técnicas usadas em Engenharia de Controle para análise e projeto de sistemas. Eles são complementares às técnicas no domínio da frequência (função de transferência) e compreendem o que alguns autores chamam de “controle moderno”. Neste capítulo introduzimos algumas noções básicas sobre o assunto. 2.1 O que é espaço de estados? Um modelo de espaço de estados para um sistema linear invariante no tempo (SLIT) é um conjunto de equações diferenciais ordinárias simultâneas de 1a ordem. Por exemplo: \\[\\begin{aligned} \\dot{x}_1 &amp;= 2x_1-x_2+u\\\\ \\dot{x}_2 &amp;= -x1 \\end{aligned}\\] onde \\(u\\) é o sinal de entrada e os sinais \\(x_1\\) e \\(x_2\\) são chamados de estados do sistema. As duas primeiras equações são chamadas de equações de estado do sistema. À equação de estados juntamos a equação de saída do sistema \\[ y = 3x_1+4x_2 \\] que descreve o sinal de saída \\(y\\) em função dos estados. Isso é um pouco diferente do que você aprendeu em Controle I e ASL, onde os sistemas são representados por uma única EDO de ordem elevada, que contém apenas um sinal de entrada e um sinal de saída. Em uma equação de estados temos várias equações diferenciais simultâneas em múltiplos sinais (funções do tempo) \\(x_1\\), \\(x_2\\), etc. O número \\(n\\) de estados deve ser igual ao número de equações de estado. \\(n\\) é equivalente a ordem do sistema. Veremos depois que isso equivale a ordem da função de transferência do sistema. Uma equação de estados substitui uma EDO de ordem \\(n\\) por \\(n\\) equações de ordem 1. Note entretanto que não conseguimos resolver essas equações de forma independente, devido à interdependência delas. A representação de estados é uma forma alternativa de modelar matematicamente de um sistema. Ela não exclui a representação do sistema por função de transferência. Observação: \\[\\begin{aligned} \\frac{dx(t)}{dt} &amp;= \\dot{x}(t) = \\dot{x}\\\\ \\frac{d^2x(t)}{dt^2} &amp;= \\ddot{x}(t) = \\ddot{x} \\end{aligned}\\] 2.2 O que é estado? Matematicamente, os estados funções do tempo intermediárias que precisam ser resolvidas para obtermos o sinal de interesse do sistema, isto é, o sinal de saída. Fisicamente, os estados denotam grandezas físicas importantes, que determinam como o sistema evolui, mas não são necessariamente mensuráveis. Um bom exemplo é o modelo físico de um gás. Em termodinâmica, a temperatura de um gás é uma medida importante que pode ser mensurada. No entanto, a teoria estabelece que a temperatura é uma função do grau de agitação molecular do gás, ou seja, é determinada a partir da velocidades de suas moléculas. Contudo, uma amostra de gás contém um número muito grande de moléculas, não sendo possível medir a velocidade individual de cada uma, embora possamos estabelecer um modelo teórico que descreva como elas se movimentam. Desta forma, no modelo de um sistema dinâmico de um gás, as velocidades indidividuais podem ser vistas como os estados do sistema, cuja evolução temporal é importante e passível de modelagem, mas a temperatura é efetivamente o sinal de saída, aquilo que realmente conseguimos medir macroscopicamente. 2.3 Sistemas LIT SISO Para um sistema linear invariante no tempo de uma entrada \\(u\\) e uma saída \\(y\\), a representação padrão de estados é: Derivada de um estado = combinação linear de todos os estados e da entrada. Por exemplo: \\[ \\dot{x}_3 = -2x_1-3x_2-4x_5 + 10u \\] Para cada estado podemos ter uma combinação linear diferente, por exemplo: \\[ \\begin{aligned} \\dot{x}_1 &amp;= x_2\\\\ \\dot{x}_2 &amp;= x_3\\\\ \\dot{x}_3 &amp;= -2x_1-3x_2-4x_5 + 10u \\end{aligned} \\] 2.4 Representação matricial O modelo acima pode ser representado de forma mais compacta se usarmos notação matricial: Vetor de estados: \\[ \\mathbf{x}=\\left[\\begin{matrix}x_{1}\\\\x_{2}\\\\x_{3}\\end{matrix}\\right] \\] Derivada temporal do vetor de estados \\[ \\dot{\\mathbf{x}}=\\left[\\begin{matrix}\\dot{x}_1\\\\\\dot{x}_2\\\\\\dot{x}_3\\end{matrix}\\right] \\] Repare o uso de negrito para representar grandezas matriciais O número de equações de estado (diferenciais) é igual ao número de variáveis de estado, que é igual a ordem do sistema. A interpretação de ordem aqui é a mesma de “ordem” da equação diferencial Desta forma, as três equações de estados podem ser colocadas sob a forma: \\[\\begin{aligned} \\left[\\begin{matrix}\\dot{x}_1\\\\\\dot{x}_2\\\\\\dot{x}_3\\end{matrix}\\right]&amp;=\\left[\\begin{matrix}0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\-2 &amp; -3 &amp; -4\\end{matrix}\\right]\\left[\\begin{matrix}x_{1}\\\\x_{2}\\\\x_{3}\\end{matrix}\\right]+\\left[\\begin{matrix}0\\\\0\\\\10\\end{matrix}\\right]u\\\\ \\dot{\\mathbf{x}}&amp;=\\left[\\begin{matrix}0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\\\-2 &amp; -3 &amp; -4\\end{matrix}\\right]\\mathbf{x}+\\left[\\begin{matrix}0\\\\0\\\\10\\end{matrix}\\right]u \\end{aligned}\\] No nosso caso, vamos sempre considerar que o sistema é 1-entrada-1-saída (SISO) e assim, as matrizes de um sistema de ordem \\(n\\) tem, necessariamente, as dimensões: \\(\\mathbf{A}\\): \\(n\\times n\\) (quadrada de ordem \\(n\\)) \\(\\mathbf{B}\\): \\(n\\times 1\\) (vetor coluna de \\(n\\) elementos) \\(\\mathbf{C}\\): \\(n\\times n\\) (vetor linha de \\(n\\) elementos) \\(D\\): \\(1\\times 1\\) (escalar) Exemplo: \\[\\begin{aligned} \\mathbf{\\dot{x}} &amp;= \\left[\\begin{array}{rr} 0 &amp; 1\\\\-1 &amp; -1 \\end{array} \\right]\\mathbf{x} + \\left[\\begin{array}{r} -2 \\\\ 5\\end{array}\\right]u\\\\ y &amp;= \\left[\\begin{array}{rr} 3 &amp; 1\\end{array} \\right]\\mathbf{x} \\end{aligned}\\] 2.5 Sistemas LIT MIMO Quando o sistema possui mais de uma entrada ou saída (SISO), a representação por espaço de estados muda ligeiramente. Apenas mudanças nas matrizes \\(\\mathbf{B}\\) e \\(\\mathbf{C}\\) são necessárias. Para um sistema com \\(m\\) entradas e \\(p\\) saídas: A matriz \\(\\mathbf{B}\\) deve ter \\(m\\) colunas A matriz \\(\\mathbf{C}\\) deve ter \\(p\\) linhas O sinal de entrada \\(u\\) passa a ser um vetor coluna \\(\\mathbf{u}\\), onde cada elemento é um sinal de entrada diferente, isto é \\(\\mathbf{u} = \\begin{bmatrix}u_1 &amp; u_2 &amp; \\ldots &amp; u_m\\end{bmatrix}^T\\) O sinal de y \\(u\\) passa a ser um vetor coluna \\(\\mathbf{y}\\), onde cada elemento é um sinal de de saída diferente, isto é \\(\\mathbf{y} = \\begin{bmatrix}y_1 &amp; y_2 &amp; \\ldots &amp; y_p\\end{bmatrix}^T\\) Se a ordem do sistema é \\(n\\), então a matriz \\(\\mathbf{A}\\) permanece \\(n\\times n\\). Exemplo: este é um sistema de 2a ordem, 2 entradas e 3 saídas. \\[\\begin{align} \\dot{\\mathbf{x}} &amp;= \\left[\\begin{array}{rr} 0 &amp; 1 \\\\ -7 &amp; -6 \\end{array}\\right] \\mathbf{x} + \\left[\\begin{array}{rr} 1 &amp;0 \\\\ 2 &amp;-3\\end{array}\\right]\\mathbf{u}\\\\ \\mathbf{y} &amp;= \\left[\\begin{array}{rr}2 &amp; 4\\\\ 1&amp; 0\\\\ 0 &amp;1\\end{array}\\right]\\mathbf{x} + \\left[\\begin{array}{rr}1 &amp; 0 \\\\0 &amp; 0 \\\\ 0 &amp; 0 \\end{array}\\right]\\mathbf{u} \\end{align}\\] 2.6 Sistemas não-lineares Sistemas não-lineares também possuem representação de estados. Na verdade, no estudo de sistemas não-lineares, a representação de estados é canônica, pois não existe uma representação universal do tipo função de transferência para sistemas não-lineares. Para um sistema de ordem \\(n\\), com \\(m\\) entradas e \\(p\\) saídas, a representação é: \\[ \\dot{\\mathbf{x}} = \\mathbf{F(x,u)} = \\begin{bmatrix}f_1(x_1,\\ldots,x_n,u_1,\\ldots, u_m) \\\\ f_2(x_1,\\ldots,x_n,u_1,\\ldots, u_m) \\\\ \\ldots \\\\ f_n(x_1,\\ldots,x_n,u_1,\\ldots, u_m) &amp;\\end{bmatrix} \\] onde \\(\\mathbf{F}\\) é uma função vetorial com \\(n\\) elementos. A equação de saída é: \\[ {\\mathbf{y}} = \\mathbf{G(x,u)} = \\begin{bmatrix}g_1(x_1,\\ldots,x_n,u_1,\\ldots, u_m) \\\\ g_2(x_1,\\ldots,x_n,u_1,\\ldots, u_m) \\\\ \\ldots \\\\ g_p(x_1,\\ldots,x_n,u_1,\\ldots, u_m) &amp;\\end{bmatrix} \\] Exemplo: sistema MAGLEV Equação de movimento (lei de Newton): \\[ m\\ddot{x} = mg - f(x,I) \\] Força magnética: \\[ f(x,I) = \\frac{kI^2}{(x+\\mu)^2} \\] Estados: Posição \\(x\\) Velocidade \\(v = \\dot{x}\\) Equações de estado: \\[\\begin{aligned} \\dot{x} &amp;= v\\\\ \\dot{v} &amp;= g - f(x,I)/m = g - \\frac{kI^2}{m(x+\\mu)^2} \\end{aligned}\\] ou: \\[ \\begin{bmatrix} \\dot{x} \\\\ \\dot{v}\\end{bmatrix} = \\begin{bmatrix} v \\\\ g - \\frac{kI^2}{m(x+\\mu)^2}\\end{bmatrix} \\] A equação de saída é simplesmente \\[ y = x \\] Note que \\(g\\), \\(k\\), \\(m\\) e \\(\\mu\\) são constantes. 2.7 Equilíbrio A idéia de equilíbrio é fundamental em sistemas. Fisicamente, um estado de equilíbrio é aquele no qual o sistema não evoloui no tempo, permanece parado, seus sinais constantes, sem variação temporal. Em sistemas não-lineares definimos matematicamente como ponto de equilíbrio os valores fixos do vetor de estados \\(\\mathbf{x}_0\\) e de entrada \\(\\mathbf{u}_0\\) que anulam a função \\(\\mathbf{F(x,u)}\\), isto é, satisfazem: \\[ \\mathbf{F(x_0,u_0)} = \\mathbf{0} \\] O equilíbrio de um sistema possui interpretação física importante e está intimamente relacionado à estabilidade do sistema. Um sistema não linear pode ter vários pontos de equilíbrio. Um sistema LIT possui sempre um único ponto de equilíbrio dado por \\(\\mathbf{x_0=0}\\) e \\(\\mathbf{u_0=0}\\). Exemplo: sistema MAGLEV Em equilíbrio o sistema está totalmente parado, \\(v=0\\). O cilindro é mantido a uma distância \\(x_0\\) do imã, sob uma corrente \\(I_0\\). As equações de equilíbrio são: \\[\\begin{aligned} v &amp;= 0\\\\ f(x_0,I_0) &amp;= mg \\end{aligned}\\] Apicando a equação da força magnética, temos a relação detalhada: \\[ \\frac{kI_0^2}{(x_0+\\mu)^2} = mg \\Rightarrow kI_0^2 = mg(x_0+\\mu)^2 \\] 2.8 Linearização Um modelo linearizado é um modelo que tenta aproximar a evolução temporal de um sistema não-linear próximo do ponto de equilíbrio, isto é, supondo que os estados \\(\\mathbf{x}(t)\\) não diferem muito de \\(\\mathbf{x_0}\\). Modelos linearizados também são chamados de modelo de perturbação ou modelo de pequenos sinais. \\[ {\\mathbf{x}} \\approx \\mathbf{x}_0+ \\Delta \\mathbf{x} \\] com \\(\\Delta \\mathbf{x}\\) pequeno e \\(\\mathbf{x}_0\\) o ponto de equilíbrio. A maioria dos controladores que projetamos são lineares e o projeto deles é feito com base na aproximação linear do sistema. Isso ocorre porque a teoria de sistemas lineares é bem consolidada: conseguimos resolver as equações analítica e numericamente. Para sistemas não lineares essa tarefa é muito mais complicada, quando não impossível. Para linearizar um sistema, encontramos as aproximações em série de Taylor das funções \\(\\mathbf{F}\\) e \\(\\mathbf{G}\\), truncadas no termo linear, em torno do ponto de equilíbrio. \\[\\begin{aligned} \\mathbf{F(x,u)} &amp;\\approx \\mathbf{F(x_0,u_0)} + \\mathbf{A\\,\\Delta x} + \\mathbf{B\\,\\Delta u}\\\\ \\mathbf{G(x,u)} &amp;\\approx \\mathbf{G(x_0,u_0)} + \\mathbf{C\\,\\Delta x} + \\mathbf{D\\,\\Delta u} \\end{aligned}\\] onde as matrizes \\(\\mathbf{A}\\), \\(\\mathbf{B}\\), \\(\\mathbf{C}\\) e \\(\\mathbf{D}\\) são os seguintes Jacobianos. \\[\\begin{aligned} \\mathbf{A} &amp;= \\left.\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}}\\right|_{\\mathbf{x = x_0}, \\mathbf{u=u_0}}\\\\ \\mathbf{B} &amp;= \\left.\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{u}}\\right|_{\\mathbf{x = x_0}, \\mathbf{u=u_0}}\\\\ \\mathbf{C} &amp;= \\left.\\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{x}}\\right|_{\\mathbf{x = x_0}, \\mathbf{u=u_0}}\\\\ \\mathbf{D} &amp;= \\left.\\frac{\\partial \\mathbf{G}}{\\partial \\mathbf{u}}\\right|_{\\mathbf{x = x_0}, \\mathbf{u=u_0}} \\end{aligned}\\] Exemplo: Sistema MAGLEV \\[ \\mathbf{F}(x,v,I) = \\begin{bmatrix} v \\\\ g - \\frac{kI^2}{m(x+\\mu)^2}\\end{bmatrix} \\] Temos então: \\[\\begin{aligned} f_1(x,v,I) &amp;= v\\\\ f_2(x,v,I) &amp;= g - \\frac{kI^2}{m(x+\\mu)^2} \\end{aligned}\\] O ponto de equilíbrio é \\((x_0,0,I_0)\\) que satisfaz: \\[ kI_0^2 = mg(x_0+\\mu)^2 \\] Os Jacobianos são: \\[\\begin{aligned} \\mathbf{A} &amp;= \\left.\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}}\\right|_{x=x_0, v=0, I=I_0} = \\begin{bmatrix}\\frac{\\partial f_1}{\\partial x} &amp; \\frac{\\partial f_1}{\\partial v} \\\\ \\frac{\\partial f_2}{\\partial x} &amp; \\frac{\\partial f_2}{\\partial v}\\end{bmatrix}\\\\ \\mathbf{B} &amp;= \\left.\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{u}}\\right|_{x=x_0, v=0, I=I_0} = \\begin{bmatrix} \\frac{\\partial f_1}{\\partial I} \\\\ \\frac{\\partial f_2}{\\partial I}\\end{bmatrix} \\end{aligned}\\] \\[\\begin{aligned} \\frac{\\partial f_1}{\\partial x} &amp;= 0\\\\ \\frac{\\partial f_1}{\\partial v} &amp;= 1\\\\ \\frac{\\partial f_2}{\\partial x} &amp;= \\frac{2kI_0^2}{m(x_0+\\mu)^3}=\\lambda^2\\\\ \\frac{\\partial f_2}{\\partial v} &amp;= 0\\\\ \\frac{\\partial f_1}{\\partial I} &amp;= 0 \\\\ \\frac{\\partial f_2}{\\partial I} &amp;= \\frac{2kI_0}{m(x_0+\\mu)^2}=K_0 \\end{aligned}\\] Assim, os sinais do MAGLEV podem ser aproximados pela seguinte dinâmica: \\[\\begin{aligned} x &amp;\\approx x_0 + \\Delta x\\\\ v &amp;\\approx \\Delta v \\end{aligned}\\] Onde os sinais auxiliares \\(\\Delta x\\) e \\(\\Delta v\\) são descritos pela equação de estados: \\[\\begin{align} \\begin{bmatrix} \\Delta\\dot{x}\\\\ \\Delta\\dot{v}\\end{bmatrix} = \\begin{bmatrix}0 &amp; 1 \\\\ \\lambda^2 &amp; 0\\end{bmatrix}\\begin{bmatrix}\\Delta x\\\\ \\Delta v\\end{bmatrix} + \\begin{bmatrix}0\\\\ K_0\\end{bmatrix}\\Delta I \\end{align}\\] \\(\\Delta I\\) é a variação de corrente do imã em torno do valor de equilíbrio \\(I_0\\), \\(\\Delta I=I-I_0\\). "],["modelagem.html", "Capítulo 3 Modelagem 3.1 Sobre a não unicidade da representação de estados 3.2 Equação diferencial simples 3.3 Diagramas de simulação 3.4 Forma canônica de controlador (FCC) 3.5 FCC geral 3.6 Forma de Jordan ou Modal 3.7 Pólos reais e distintos 3.8 Forma de Jordan com polos reais e repetidos 3.9 Transformação de estado 3.10 Dica útil: Matriz inversa de segunda ordem 3.11 Pólos complexos conjugados", " Capítulo 3 Modelagem Neste capítulo vamos estudar diferentes formas de obter equações de estados. 3.1 Sobre a não unicidade da representação de estados Um sistema LIT pode possuir diferentes representações de estados. Isso depende de quais variáveis de estados são escolhidas para a representação. O mesmo sistema pode admitir diferentes conjuntos de estados. Isso significa que um mesmo sistema pode possuir diferentes matrizes de representação, todas de mesma ordem. A representação não é única, por isso não unicidade. Isso não ocorre com a representação por função de transferência. Um sistema possui uma e apenas uma função de transferência padrão. 3.2 Equação diferencial simples Para um sistema representado por uma EDO simples, sem derivadas do sinal de entrada, pode-se obter as equações de estado de um jeito bastante simples. Para isso basta escolher uma variável de estado como a derivada da outra, normalmente em sequência. Exemplo: \\[ \\dddot{y} + 6\\ddot{y} + 11\\dot{y} + 6y = 6u \\] Sistema de 3a ordem, então definimos os estados como a saída e suas derivadas até ordem 2. \\[\\begin{aligned} x_1 &amp;=y\\\\ x_2 &amp;=\\dot{y}\\\\ x_3 &amp;=\\ddot{y} \\end{aligned}\\] Para um sistema de 2a ordem, definimos os estados como saída e sua derivada. Generalizando, para um sistema de ordem \\(n\\), definimos a saída e todas as derivadas até ordem \\(n-1\\). Para montar a equação de estados precisamos das derivadas de cada estado. Mas pela forma como definimos cada um, as duas primeiras derivadas podem ser obtidas em função da própria definição. \\[\\begin{aligned} \\dot{x}_1 &amp;=\\dot{y} = x_2\\\\ \\dot{x}_2 &amp;=\\ddot{y} = x_3 \\end{aligned}\\] Por último, precisamos da derivada do último estado. Note que esta é: \\[\\begin{aligned} x_3 &amp;=\\dddot{y} \\end{aligned}\\] que pode ser obtida da EDO original como: \\[\\begin{aligned} \\dddot{y} &amp;= -6\\ddot{y} - 11\\dot{y} - 6y + 6u\\\\ &amp;= -6x_3 -11x_2 - 6x_1 + 6u \\end{aligned}\\] Assim as equações de estado são: \\[\\begin{aligned} \\dot{x}_1 &amp;=x_2\\\\ \\dot{x}_2 &amp;= x_3\\\\ \\dot{x}_3 &amp;=-6x_3 -11x_2 - 6x_1 + 6u \\end{aligned}\\] Agora basta converter para o formato matricial. Na matriz \\(\\mathbf{A}\\) o elemento da linha \\(i\\) e coluna \\(j\\) é o coeficiente da variável \\(j\\) na equação \\(i\\) (relativa a derivada da variável \\(i\\)). Na matriz \\(\\mathbf{B}\\) o elemento da linha \\(i\\) é simplesmente o coeficiente de \\(u\\) na equação \\(i\\). Para o exemplo, o resultado é: \\[\\begin{aligned} \\left[\\begin{array}{c}\\dot{x}_1\\\\ \\dot{x}_2\\\\ \\dot{x}_3\\\\ \\end{array}\\right] &amp;= \\left[\\begin{array}{rrr}1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0 \\\\-6 &amp; -11 &amp; -6\\end{array}\\right] \\left[\\begin{array}{c}{x}_1\\\\ {x}_2\\\\ {x}_3\\\\ \\end{array}\\right] + \\left[\\begin{array}{c}0 \\\\ 0 \\\\ 6 \\end{array}\\right]u \\end{aligned}\\] Perceba que nossa escolha inicial da sequência de estados é arbitrária. Nada impede que façamos uma permutação. por exemplo: \\[ \\begin{aligned} x_3 &amp;=y\\\\ x_2 &amp;=\\dot{y}\\\\ x_1 &amp;=\\ddot{y} \\end{aligned} \\] Tente verificar que neste caso, a equação de estados se tornaria: \\[ \\begin{aligned} \\left[\\begin{array}{c}\\dot{x}_1\\\\ \\dot{x}_2\\\\ \\dot{x}_3\\\\ \\end{array}\\right] &amp;= \\left[\\begin{array}{rrr}-6 &amp; -11 &amp; -6\\\\ 1 &amp; 0 &amp; 0\\\\0 &amp; 1 &amp; 0\\end{array}\\right] \\left[\\begin{array}{c}{x}_1\\\\ {x}_2\\\\ {x}_3\\\\ \\end{array}\\right] + \\left[\\begin{array}{c}0 \\\\ 0 \\\\ 6 \\end{array}\\right]u \\end{aligned} \\] 3.3 Diagramas de simulação Em algumas ocasiões, modelos dinâmicos surgem ou são projetados a partir de um diagrama de simulação. Esses são diagramas de blocos convencionais, tais como vistos em disciplinas anteriores, obedecendo às regras de simplificação normais. Uma característica marcante é que eles são construídos apenas com 3 elementos: o integrador, o ganho e o somador. Isso foi convecionado para, antigamente, facilitar a implementação com eletrônica analógica, i.e., amplificadores operacionais. Atualmente, utilizamos apenas para facilitar a escrita da equação de estados. Os diagramas são uma forma inteligível de ler as relações entre os estados do sistema e assim deduzir as equações de estados. 3.4 Forma canônica de controlador (FCC) A FCC é um tipo de representação útil principalmente para converter uma função de transferência em equação de estados. Considere o seguinte exemplo: \\[ \\begin{aligned} G(s) &amp;= \\frac{s+2}{s^2+7s+12} \\end{aligned} \\] Para construir um diagrama na forma canônica de controlador, faça o seguinte: Desenhe integradores em série, tantos quantos forem a ordem do sistema A entrada será o sinal mais a esquerda. A saída, o mais a direita. Realimente todos os integradores, cada um através de um ganho constante As realimentações devem ser ligadas a um único somador posicionado na entrada do integrador mais a esquerda. Se quiser organizar melhor, divida o somador em outros de duas entradas, imediatamente abaixo O valor de cada ganho de realimentação é o negativo de um coeficiente do denominador. Utilize os coeficientes de maior potência de \\(s\\) para as ligações dos integradores mais perto da entrada A saída do sistema é consturída a partir de um somador Ao somador de saída, ligue as saídas de cada integrador através de um ganho constante O valor de cada ganho é igual a um coeficiente do numerador Utilize os coeficientes de menor potência de \\(s\\) para as ligações dos integradores mais perto da saída Figure 3.1: Diagrama de simulação Para o diagrama feito, as equações de estado são: \\[ \\begin{aligned} \\dot{x}_2&amp;=x_{1}\\\\\\dot{x}_1&amp;=u - 7 x_{1} - 12 x_{2} \\end{aligned} \\] Logo a representação matricial é: \\[ \\left[\\begin{matrix}\\dot{x}_1\\\\\\dot{x}_2\\end{matrix}\\right]=\\left[\\begin{matrix}-7 &amp; -12\\\\1 &amp; 0\\end{matrix}\\right]\\left[\\begin{matrix}x_{1}\\\\x_{2}\\end{matrix}\\right]+\\left[\\begin{matrix}1\\\\0\\end{matrix}\\right]u \\] Note que os estados foram ordenados da esquerda para a direita. O que aconteceria se tivéssemos nomeado ao contrário? 3.5 FCC geral Para um sistema geral de ordem \\(n\\), com função de transferência \\[ \\begin{aligned} G(s) &amp;= \\frac{b_1s^{n-1}+b_2s^{n-2}+\\ldots b_n}{s^n+a_1s^{n-1}+a_2s^{n-2}+\\ldots + a_n} \\end{aligned} \\] Perceba que o coeficiente de maior grau do denominador foi feito igual a \\(1\\). As matrizes da forma canônica de controlador tem a seguinte estrutura \\[ \\begin{aligned} \\mathbf{A} &amp;= \\left[\\begin{array}{cccccc} -a_1 &amp; -a_2 &amp; \\ldots &amp; a_{n-1} &amp;-a_n\\\\ 1 &amp; 0 &amp; \\ldots &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; \\ldots &amp; 0 &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\ldots &amp; \\vdots&amp; \\vdots \\\\ 0 &amp; 0 &amp; \\ldots &amp; 1 &amp; 0 \\end{array}\\right]\\\\ \\mathbf{B} &amp;= \\left[\\begin{array}{cccccc} 1 \\\\ 0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{array}\\right]\\\\ \\mathbf{C} &amp;= \\left[\\begin{array}{cccccc} b_1 &amp; b_2 &amp; \\ldots &amp; b_{n-1} &amp; b_n \\end{array}\\right]\\\\ D &amp;=0 \\end{aligned} \\] Observações Matriz \\(\\mathbf{A}\\) A primeira linha é dada pelos coeficientes do denominador, com sinal trocado, ordem decrescente de potência Abaixo da segunda linha temos uma matriz identididade e uma coluna de zeros Matriz \\(\\mathbf{B}\\) Primeiro elemento \\(1\\) e os demais zero Matriz \\(\\mathbf{C}\\) Coeficientes do numerador, sem troca de sinal, ordem decrescente de potência Termo \\(D\\) Nulo (apenas se o grau do numerador for estritamente menor que o do denominador) Observacão: A função de transferência tem o grau do denominador estritamente maior que o do numerador. Caso não seja, é necessário fazer divisão longa antes de prosseguir. O termo quociente será a matriz \\(D\\). Exercício: Ache as matrizes da forma de controlador do sistema: \\[ \\begin{aligned} G(s) &amp;= \\frac{5s^2+8}{s(s+5)(s^2+9)} \\end{aligned} \\] 3.6 Forma de Jordan ou Modal Na forma modal, os estados aparecem majoritariamente desacoplados, isto é, uma equação de estados depende apenas da sua própria variável de estado e do sinal de entrada. Isso é possível sempre que o sistema tiver pólos reais e distintos. Quando o sistema tiver pólos repetidos, haverá um pequeno acoplamento entre equações, mas apenas entre os estados referentes ao mesmo pólo. Quando o sistema tiver pólos imaginários, as equações podem ser desacopladas, mas ao custo de ganhos imaginários. Para eliminar os ganhos imaginários, podemos introduzir um pequeno acoplamento entre os estados associados aos pólos conjugados. Exemplo resolvido: Figure 3.2: Diagrama em forma de Jordan Para o sistema da Fig 7.8. \\[\\begin{aligned} \\dot{z}_1 &amp;= u - 4z_1\\\\ \\dot{z}_2 &amp;= u - 3z_2\\\\ y &amp;= 2z_1-z_2 \\end{aligned}\\] Uma consequência do desacoplamento é que matriz \\(\\mathbf{F}\\) se torna diagonal. \\[\\begin{aligned} \\dot{\\mathbf{x}} &amp;= \\left[\\begin{array}{rr}-4 &amp; 0\\\\0 &amp; -3\\end{array}\\right]\\mathbf{x}+\\left[\\begin{array}{r}1\\\\1\\end{array}\\right]u\\\\ y &amp;= \\left[\\begin{array}{rr}2 &amp; -1\\end{array}\\right]\\mathbf{x} \\end{aligned}\\] A forma modal é útil para determinar rápida e intuitivamente uma propriedade chamada controlabilidade. O sistema é não-controlável quando o sinal de controle não consegue “chegar” até um determinado integrador por nenhum caminho. Algumas observações importantes: Um sistema pode perder controlabilidade quando na sua função de transferência há algum cancelamento entre pólos e zeros. Para achar a forma modal a partir da função de transferência, use expansão em frações parciais 3.7 Pólos reais e distintos Ache a expansão em frações parciais da função de transferência Faça um diagrama para cada uma das parcelas da expansão Nomeie os estados (saída dos integradores) e monte as equações normalmente Mais um exemplo de modal \\[\\begin{aligned} G(s) &amp;=\\frac{s+3}{(s+1)(s+5)(s-9)} \\end{aligned}\\] Precisamos primeiro expandir e achar os resíduos (frações parciais). É possível fazer isso usando a função “residue” do módulo scipy.signal. A funçao “apart” do módulo sympy também resolve o problema, embora nem sempre da forma esperada em problemas de engenharia. import scipy.signal as sig import numpy as np num = [1,3] den = np.poly([-1,-5,9]) r,p,k = sig.residue(num,den) r = r.round(decimals=4) p = p.round(decimals=4) print(r) ## [-0.05 -0.0357 0.0857] print(p) ## [-1. -5. 9.] Logo: \\[ G(s) = \\frac{-0.05}{s+1}-\\frac{0.03}{s+5}+\\frac{0.08}{s-9} \\] O diagrama para a representação de cada modo está a seguir As equações de estado vão ser (verifique você mesmo!): \\[ \\dot{x}_1 = -x_1-0.05u \\] \\[ \\dot{x}_2 = -5x_2-0.03u \\] \\[ \\dot{x}_3 = 9x_3+0.08u \\] A equação de saída é: \\[ y = x_1+x_2+x_3 \\] Por fim, a representação matricial: \\[ \\dot{\\mathbf{x}} = \\left[\\begin{array}{rrr} -1 &amp; 0 &amp; 0\\\\ 0 &amp; -5 &amp; 0\\\\ 0 &amp; 0 &amp; 9 \\end{array} \\right]\\mathbf{x} + \\left[\\begin{array}{r} 1 \\\\ 1 \\\\ 1 \\end{array}\\right]u \\] E a equação de saída. \\[\\begin{aligned} y = \\left[\\begin{array}{ccc}-0.05 &amp; -0.03 &amp; 0.08\\end{array}\\right]\\mathbf{x} \\end{aligned}\\] 3.8 Forma de Jordan com polos reais e repetidos Suponha que: \\[\\begin{aligned} G(s) &amp;= \\frac{16s}{(s+3)^2(s+5)} \\end{aligned}\\] Vamos calcular rapidamente os resíduos e a expansão: num = np.array([16,0]) den = np.convolve([1,3],[1,3]) den = np.convolve(den,[1,5]) r,p,k = sig.residue(num,den) print(r) ## [ 20. -24. -20.] print(p) ## [-3. -3. -5.] Então: \\[ \\begin{aligned} G(s) &amp;= \\frac{20}{(s+3)}-\\frac{24}{(s+3)^2}-\\frac{20}{s+5} \\end{aligned} \\] Observe no diagrama como devemos implementar o termo quadrático: Observe que os estágios correspondentes ao polo repetido ficam em série, e não em paralelo, diferente dos outros. Exercício: escreva a representação matricial 3.9 Transformação de estado Uma única função de transferência pode ter diferentes representações de estado (matrizes) Quando mudamos de uma representação para outra, as matrizes mudam, e os estados não são mais os mesmos. Eles adquirem outro significado físico. No entanto, as características intrínsecas do sistema, tais como pólos, zeros, estabilidade e outras permanecem as mesmas. A explicação matemática para isso é a teoria de transformações lineares. Supondo que a representação “velha” seja: \\[\\begin{aligned} \\mathbf{\\dot{x}} &amp;= \\mathbf{Ax+B}u\\\\ y &amp;= \\mathbf{Cx}+Ju \\end{aligned}\\] A mudança para um novo vetor de estados, digamos \\(\\mathbf{z}\\), é representada por uma transformação linear: \\[\\begin{aligned} \\mathbf{x} &amp;= \\mathbf{Tz} \\end{aligned}\\] onde \\(\\mathbf{T}\\) é uma matriz quadrada de ordem \\(n\\), inversível (ou seja, é possível “ir” e “voltar” com a mudança). Esperamos que, usando o novo vetor de estados \\(\\mathbf{z}\\), a representação seja algo como: \\[\\begin{aligned} \\mathbf{\\dot{z}} &amp;= \\mathbf{A_nz+B_n}u\\\\ y &amp;= \\mathbf{C_nz}+D_nu \\end{aligned}\\] Pode-se mostrar que a representação “nova” se relaciona com a “velha”, usando a matriz de transformação \\(\\mathbf{T}\\) da seguinte forma: \\[\\begin{aligned} \\mathbf{A}_n &amp;= \\mathbf{T^{-1}AT}\\\\ \\mathbf{B}_n &amp;= \\mathbf{T^{-1}B}\\\\ \\mathbf{C}_n &amp;= \\mathbf{CT}\\\\ D_n &amp;= D \\end{aligned}\\] A transformação para forma de Jordan, em particular, é um procedimento que chamamos de diagonalização 3.10 Dica útil: Matriz inversa de segunda ordem Para fazer transformações em sistemas de ordem 2, precisamos da inversa da matriz de transformação. Um regra rápida para achar a inversa de 2a ordem é: Troque a ordem dos elementos da diagonal principal Inverta o sinal dos elementos não diagonais Divida a matriz inteira pelo determinante da matriz original (supondo que ele não é zero) \\[\\begin{aligned} \\left[\\begin{array}{cc} a&amp;b\\\\c&amp;d \\end{array}\\right]^{-1} &amp;= \\frac{\\left[\\begin{array}{cc} d&amp;-b\\\\-c&amp;a \\end{array}\\right]}{ad-bc} \\end{aligned}\\] Lembre-se que isso só vale para matriz de ordem 2! Exercício: para a função de transferência \\[\\begin{aligned} G(s) =\\frac{3s^2-1}{(s+1)(s+7)(s+5)} \\end{aligned}\\] Faça o diagrama de blocos da forma de controlador Obtenha as matrizes da forma de controlador Obtenha as matrizes da forma modal Ache as matrizes se aplicada a transformação \\[\\begin{aligned} \\mathbf{T} =\\left[\\begin{array}{cc}1&amp;-1\\\\1&amp;1 \\end{array}\\right] \\end{aligned}\\] 3.11 Pólos complexos conjugados Quando os polos são complexos, somos tentados a usar ganhos complexos no diagrama de blocos, o que não é possível de realizar fisicamente. Quando há polos complexos e, consequentemente, resíduos complexos, podemos fazer um artifício baseado na própria expansão em frações para nos “livrarmos” de qualquer número complexo presente. Suponha, por exemplo: \\[\\begin{aligned} G(s) &amp;= \\frac{100}{s(s^2+2s+5)} \\end{aligned}\\] A expansão em frações parciais dessa função é: \\[\\begin{aligned} G(s) &amp;= \\frac{20}{s}+\\frac{-10+j5}{s+1-j2}+\\frac{-10-j5}{s+1+j2} \\end{aligned}\\] Os pólos complexos usam ganhos de realimentação e de saída complexos. Para evitar isso, podemos usar um artifício que acopla os modos complexos entre si, mas continuando isolados dos outros modos do sistema Para um caso geral de conjugados \\[\\begin{aligned} \\frac{a+jb}{s-\\sigma-j\\omega}+\\frac{a-jb}{s-\\sigma+j\\omega} \\end{aligned}\\] O diagrama de blocos (dedução um pouco trabalhosa) equivalente é: As equações de estado são as seguintes: \\[\\begin{aligned} \\dot{R} &amp;= \\sigma R-\\omega I + u\\\\ \\dot{I} &amp;= \\omega R-\\sigma I + u\\\\ y &amp;= 2a\\, R -2b\\, I \\end{aligned}\\] Assim, a contribuição do par conjugado para a forma modal é a seguinte: Na matriz de estados, encaixe a seguinte matrix \\(2\\times 2\\) feita a partir das partes real e imaginária dos pólos complexos \\[\\begin{aligned} \\left[\\begin{array}{cc} \\sigma &amp; -\\omega\\\\ \\omega &amp; \\sigma\\end{array}\\right] \\end{aligned}\\] Na matriz de entrada, a contribuição é apenas um vetor coluna de 1’s Na matriz de saída, a contribuição é uma linha de dois elementos construído a partir das partes real e imaginária do resíduo complexo \\[\\begin{aligned} \\left[\\begin{array}{cc} 2a &amp; -2b\\end{array}\\right] \\end{aligned}\\] Voltando ao exemplo… \\[\\begin{aligned} G(s) &amp;= \\frac{20}{s}+\\frac{-10+j5}{s+1-j2}+\\frac{-10-j5}{s+1+j2} \\end{aligned}\\] Para a parcela complexa, vamos tomar como referência o pólo \\(s=-1+j2\\). Para este, \\(\\sigma = -1\\) e \\(\\omega=2\\) O resíduo complexo correspondente é \\(-10+j5\\). Então, neste caso: \\(a=-10\\) e \\(b=5\\) Assim as equações de estado serão: \\[\\begin{aligned} \\dot{x}_1 &amp;= u\\\\ \\dot{x}_2 &amp;= -x_2-2x_3+u\\\\ \\dot{x}_3 &amp;= 2x_2-x_3+u\\\\ y &amp;= 20x_1 -20x_2+10x_3 \\end{aligned}\\] Construa as matrizes a partir daqui. Observe que a matriz de estados não é mais diagonal (mas é quase) "],["análise-de-sistemas-com-espaço-de-estados.html", "Capítulo 4 Análise de sistemas com espaço de estados 4.1 Sinal de saída e função de transferência 4.2 Pólos de um sistema no espaço de estados (Autovalores) 4.3 Zeros do sistema 4.4 Estabilidade no espaço de estados", " Capítulo 4 Análise de sistemas com espaço de estados Dada uma entrada \\(u(t)\\) e uma condição inicial dos estados \\(\\mathbf{x}(0)\\), podemos resolver a equação diferencial (matricial) dos estados e determinar a saída do sistema. Isso pode ser feito com a transformada de Laplace da mesma forma como se fosse uma equação escalar. Devemos apenas atentar que para uma equação matricial, a divisão é substituída pela multiplicação por matriz inversa. \\[\\begin{aligned} \\mathbf{\\dot{x}} &amp;= \\mathbf{Ax+B}u\\\\ \\mathcal{L}\\{\\mathbf{\\dot{x}}\\} &amp;= \\mathcal{L}\\{\\mathbf{Ax+B}u\\}\\\\ s\\mathbf{X}(s)-\\mathbf{x}(0) &amp;= \\mathbf{AX}(s)+\\mathbf{B}U(s)\\\\ s\\mathbf{X}(s)-\\mathbf{AX}(s)&amp;=\\mathbf{x}(0)+\\mathbf{B}U(s)\\\\ (s\\mathbf{I-A})\\mathbf{X(s)} &amp;= \\mathbf{x}(0)+\\mathbf{B}U(s)\\\\ \\mathbf{X(s)} &amp;= (s\\mathbf{I-A})^{-1}\\mathbf{x}(0)+(s\\mathbf{I-A})^{-1}\\mathbf{B}U(s)\\\\ \\end{aligned}\\] O termo \\((s\\mathbf{I-A})^{-1}\\mathbf{x}(0)\\) é a resposta de entrada nula, devido sua independência da função de entrada. O termo \\((s\\mathbf{I-A})^{-1}\\mathbf{B}U(s)\\) é a resposta de estado nulo, devido sua independência das condições iniciais. Para determinar os estados no domínio do tempo \\(\\mathbf{x}(t)\\) bastaria tirar a transformada inversa. Assim teríamos a resposta de cada um dos estados em função do tempo. 4.1 Sinal de saída e função de transferência Olhando agora o sinal de saída: \\[\\begin{aligned} y &amp;= \\mathbf{Cx} + Du\\\\ Y(s) &amp;= \\mathbf{CX(s)} + DU(s) \\end{aligned}\\] Substituindo o que encontramos para \\(\\mathbf{X}(s)\\): \\[\\begin{aligned} Y(s) &amp;= \\mathbf{C}(s\\mathbf{I-A})^{-1}\\mathbf{x}(0)+\\mathbf{C}(s\\mathbf{I-A})^{-1}\\mathbf{B}U(s) + DU(s) \\end{aligned}\\] Colocando \\(U(s)\\) em evidência agora: \\[\\begin{aligned} Y(s) &amp;= \\mathbf{C}(s\\mathbf{I-A})^{-1}\\mathbf{x}(0)+\\left[\\mathbf{C}(s\\mathbf{I-A})^{-1}\\mathbf{B} + D\\right]U(s) \\end{aligned}\\] Quando as condições iniciais são nulas \\(\\mathbf{x}(0)=\\mathbf{0}\\), o termo que sobra é um escalar: \\[\\begin{aligned} Y(s) &amp;= \\left[\\mathbf{C}(s\\mathbf{I-A})^{-1}\\mathbf{B} + D\\right]U(s)\\\\ \\frac{Y(s)}{U(s)} &amp;= \\mathbf{C}(s\\mathbf{I-A})^{-1}\\mathbf{B} + D \\end{aligned}\\] Reconhecemos a última equação como a função de transferência do sistema definida em termos das matrizes da representação de espaço de estados. 4.2 Pólos de um sistema no espaço de estados (Autovalores) Na equação da função de transferência, o termo principal é \\((s\\mathbf{I-A})^{-1}\\). Sabemos que a inversa de qualquer matriz pode ser descrita como sua adjunta divido pelo seu determinante. O que vai sobrar no denominador da função de transferência, portanto, é \\(\\det (s\\mathbf{I-A})\\). Sabemos que os pólos são as raízes do denominador de uma função de transferência. Ora, se o denominador é dado pelo determinante acima, então os pólos do sistema são dados pelas soluções da equação: \\[\\begin{aligned} \\det (s\\mathbf{I-A}) = 0 \\end{aligned}\\] Os valores de \\(s\\) que satisfazem essa equação são chamados em álgebra linear de autovalores da matriz e de desempenham um papel importante em vários problemas de Engenharia. Em Python vc pode calcular os autovalores do sistema usando a funçao “pole()” da biblioteca control, ou usar a biblioteca linalg do NumPy para resolver o problema de autovalor diretamente na matriz de estados do sistema. Note, porém, que a função “eig()” do NumPy devolve não apenas os autovalores, mas também os autovetores associados também. Solução manual (você precisa saber fazer manualmente pelo menos os casos de ordem 2): \\[\\begin{aligned} s\\mathbf{I-A} &amp;= s\\left[\\begin{array}{cc}1 &amp; 0\\\\0 &amp; 1\\end{array}\\right]-\\left[\\begin{array}{cc}-7 &amp; -12\\\\1 &amp; 0\\end{array}\\right]\\\\ &amp;= \\left[\\begin{array}{cc}s+7 &amp; 12\\\\-1 &amp; s\\end{array}\\right] \\end{aligned}\\] A inversa da matriz é: \\[\\begin{aligned} (s\\mathbf{I-A})^{-1} &amp;= \\frac{\\left[\\begin{array}{cc}s &amp; -12\\\\1 &amp; s+7\\end{array}\\right]}{s(s+7)+12} \\end{aligned}\\] Faz-se agora o produto pela esquerda: \\[\\begin{aligned} \\mathbf{C}(s\\mathbf{I-A})^{-1} &amp;= \\frac{\\left[\\begin{array}{cc}1 &amp; 2\\end{array}\\right]\\left[\\begin{array}{cc}s &amp; -12\\\\1 &amp; s+7\\end{array}\\right]}{s(s+7)+12}\\\\ &amp;= \\frac{\\left[\\begin{array}{cc}s+2 &amp; 2s+2\\end{array}\\right]}{s^2+7s+12} \\end{aligned}\\] E o resultado com o produto pela direita: \\[\\begin{aligned} \\mathbf{C}(s\\mathbf{I-A})^{-1}\\mathbf{B} &amp;= \\frac{\\left[\\begin{array}{cc}s+2 &amp; 2s+2\\end{array}\\right]\\left[\\begin{array}{c}1 \\\\ 0\\end{array}\\right]}{s^2+7s+12}\\\\ &amp; = \\frac{s+2}{s^2+7s+12} \\end{aligned}\\] Exercício: Calcule manualmente e confira sua resposta com Python, a função de transferência do sistema \\[\\begin{aligned} \\dot{\\mathbf{x}} &amp;= \\left[\\begin{array}{cc}-1 &amp; 7\\\\ 9 &amp; 0\\end{array}\\right]\\mathbf{x} + \\left[\\begin{array}{cc} 5 \\\\ -3\\end{array}\\right]u\\\\ y &amp;= \\left[\\begin{array}{cc}3 &amp; 2\\end{array}\\right]\\mathbf{x} \\end{aligned}\\] 4.3 Zeros do sistema Na descrição entrada-saída (função de transferência) de um sistema, definimos zeros de uma forma bem matemática: são as raízes do numerador. No entanto, os zeros possuem uma definição um pouco mais física. São chamados zeros os modos (exponenciais) que, se colocados na entrada do sistema, produzem uma saída identicamente nula. Isso permite estabelecer as expressões que definem os zeros do sistema em função das matrizes de espaço de estados. Para achar os zeros, basta resolver a equação polinomial: \\[\\begin{aligned} \\det\\,\\left[\\begin{array}{cc}s\\mathbf{I-A} &amp; -\\mathbf{B}\\\\ \\mathbf{C} &amp; D\\end{array}\\right]=0 \\end{aligned}\\] Solução: Precisamos montar a matriz. No caso, já calculamos \\(s\\mathbf{I-A}\\) no exemplo anterior, então basta concatenar as demais: \\[\\begin{aligned} s\\mathbf{I-A} &amp;= \\left[\\begin{array}{cc}s+7 &amp; 12\\\\-1 &amp; s\\end{array}\\right]\\\\ \\Rightarrow \\left[\\begin{array}{ccc}s\\mathbf{I-A} &amp; -\\mathbf{B}\\\\ \\mathbf{C} &amp; D\\end{array}\\right]&amp;= \\left[\\begin{array}{ccc}s+7 &amp; 12 &amp; -1\\\\-1 &amp; s &amp; 0\\\\ 1 &amp; 2 &amp; 0 \\end{array}\\right] \\end{aligned}\\] Basta agora calcular o determinante. \\[\\begin{aligned} \\det \\left[\\begin{array}{ccc}s+7 &amp; 12 &amp; 1\\\\-1 &amp; s &amp; 0\\\\ 1 &amp; 2 &amp; 0 \\end{array}\\right] &amp;= \\det \\left[\\begin{array}{cc}-1 &amp; s \\\\ 1 &amp; 2 \\end{array}\\right] = -2-s \\end{aligned}\\] Igualando a zero, temos: \\[\\begin{aligned} -2-s =0 \\Rightarrow s = -2 \\end{aligned}\\] Em Python, a função “zero()” é capaz de determinar os zeros a partir da representação do sistema 4.4 Estabilidade no espaço de estados O conceito de estabilidade no espaço de estados é um pouco diferente do que aprendemos na representação entrada-saída. A estabilidade é relativa a um ponto de equilíbrio do sistema. Um sistema é estável se, dada uma condição inicial \\(\\mathbf{x}(0)\\) próxima do ponto de equilíbrio, o estado \\(\\mathbf{x}(t)\\) do sistema retorna para o ponto de equilíbrio inicial e ali permanece. Um sistema linear possui apenas um ponto de equilíbrio, o vetor nulo \\(\\mathbf{x}= \\left[\\begin{array}{cccc}0 &amp; 0 &amp; \\ldots &amp; 0\\end{array}\\right]\\). É fácil de verificar que esse é um ponto de equilíbrio. Dada a equação de estados \\[\\begin{aligned} \\mathbf{\\dot{x}} &amp;= \\mathbf{Ax+B}u \\end{aligned}\\] vemos que se \\(u=0\\) e se \\(\\mathbf{x=0}\\), então todo o lado direito se anula, o que implica que \\(\\mathbf{\\dot{x}=0}\\). Ou seja, o sistema não evolui com o tempo, fica sempre no “mesmo lugar”. Um sistema linear será estável se, dada uma condição inicial diferente de zero do vetor de estados, o vetor \\(\\mathbf{x}(t)\\) voltar para zero em um determinado intervalo de tempo. Como já sabemos, o sistema é estável quando todos os seus pólos estão no semi-plano esquerdo (SPE). Como no espaço de estados os pólos são autovalores da matriz de estados \\(\\mathbf{A}\\), então o sistema será estável se todos esses autovalores tiverem parte real estritamente negativa. Isso garante que quando passar um longo tempo, isto é, \\(t\\rightarrow \\infty\\), os estados tenderão a zero, ou seja \\(\\mathbf{x}(t) \\rightarrow \\mathbf{0}\\). Isso é chamado também de estabilidade assintótica. Exemplo: verifique se o sistema abaixo é estável \\[\\begin{aligned} \\dot{\\mathbf{x}}= \\left[\\begin{array}{cc}0 &amp;1\\\\ -3 &amp; -7\\end{array}\\right]\\mathbf{x} + \\left[\\begin{array}{c}1\\\\ 2\\end{array}\\right]u \\end{aligned}\\] Solução manual: \\[\\begin{align} s\\mathbf{I-A} &amp;= s \\left[\\begin{matrix}1 &amp; 0\\\\0 &amp; 1\\end{matrix}\\right] - \\left[\\begin{matrix}0 &amp; 1\\\\-3 &amp; -7\\end{matrix}\\right] \\\\ &amp;= \\left[\\begin{matrix}s &amp; 0\\\\0 &amp; s\\end{matrix}\\right] - \\left[\\begin{matrix}0 &amp; 1\\\\-3 &amp; -7\\end{matrix}\\right] \\\\ &amp;= \\left[\\begin{matrix}s &amp; -1\\\\3 &amp; s + 7\\end{matrix}\\right] \\end{align}\\] Logo: \\[\\begin{align} |s\\mathbf{I-A}| &amp;= \\left| \\left[\\begin{matrix}s &amp; -1\\\\3 &amp; s + 7\\end{matrix}\\right] \\right|\\\\ &amp;= s^{2} + 7 s + 3 \\end{align}\\] Igualando o polinômio característico a zero temos as raízes \\(s = -6.541\\) e \\(s = -0.4586\\). Ambas possuem parte real negativa, logo o sistema é estável. Usando Python: import numpy as np A = np.array([[0,1],[-3, -7]]) np.linalg.eig(A)[0] ## array([-0.45861873, -6.54138127]) A função “eig” do submódulo “numpy.linalg” calcula os autovalores e autovetores de uma matriz quadrada. O primeiro argumento de saída (por isso o “[0]”) fornece os autovalores, que neste caso correspondem ao que foi calculado manualmente. "],["realimentação-de-estados.html", "Capítulo 5 Realimentação de estados 5.1 Análise da realimentação de estados 5.2 Forma canônica de controlador 5.3 Método de Ackermann 5.4 Introdução da referência 5.5 Escolha dos pólos 5.6 Estimadores de estado 5.7 Compensador dinâmico 5.8 Controle integral", " Capítulo 5 Realimentação de estados A principal técnico de controle em espaço de estados é o que chamamos de “realimentação de estados”. A estratégia básica é fazer a lei de controle \\(u\\) ser proporcional ao vetor de estados. \\[\\begin{align*} u = -\\mathbf{Kx} \\end{align*}\\] Isto lembra um pouco o controle proporcional: realimentação negativa e o controlador é apenas uma constante. Mas a diferença básica é que, como o \\(\\mathbf{x}\\) é um vetor, o controlador \\(\\mathbf{K}\\) tem que ser um vetor também. O sinal de controle é um escalar. Sendo \\(\\mathbf{x}\\) um vetor coluna de \\(n\\) elementos, então \\(\\mathbf{K}\\) deve ser um vetor linha de \\(n\\) elementos. Assim: \\[\\begin{align*} \\mathbf{K}= \\left[\\begin{array}{cccc}K_1 &amp; K_2 &amp; \\ldots &amp; K_n\\end{array}\\right] \\end{align*}\\] O objetivo inicial da realimentação de estados é fazer com que os estados do sistema caminhem para zero (ponto de equilíbrio) a partir de um estado inicial \\(\\mathbf{x}(0)\\neq \\mathbf{0}\\), em regime permanente (isto é, passado um longo tempo). Esse problema é chamado de regulação. É possível mostra que se o controlador é capaz de fazer regulação de estados, podemos fazer a saída atingir qualquer valor, que é o objetivo do sistema de controle. Observação importante: para o algoritmo funcionar supomos que todos os estados são conhecidos para calcular a ação de controle. Isso quase sempre não é verdade. Os estados são grandezas internas que, às vezes, nem conseguimos medir. Mas mesmo quando é possível, pode não ser economicamente viável comprar sensores para medir todos os estados (um sistema de ordem elevada). O único sinal que está disponível, por definição, é o sinal de saída. Na prática o que se faz é construir um sistema auxiliar que forneça uma estimativa dos estados reais a partir do sinal de saída. Esse sistema é conhecido como estimador ou observador de estados. O projeto e análise do observador de estados será visto mais a frente. Por enquanto vamos considerar que é possível medir todos os estados do sistema para fazer a realimentação 5.1 Análise da realimentação de estados Para entender como projetar o controlador, precisamos entender o que acontece com o sistema quando a estratégia é implementada. Seja um sistema: \\[\\begin{align*} \\mathbf{\\dot{x}} &amp;= \\mathbf{Ax+B}u \\end{align*}\\] Se usarmos a lei de controle \\(u = -\\mathbf{Kx}\\), a equação deixará de ter entrada, podendo ser resolvida a partir da condição inicial. \\[\\begin{align*} \\mathbf{\\dot{x}} &amp;= \\mathbf{Ax+B(-Kx)}\\\\ &amp;= \\mathbf{Ax-BKx}\\\\ &amp;= \\mathbf{(A-BK)x}\\\\ \\mathbf{\\dot{x}} &amp;= \\mathbf{A}_m \\mathbf{x} \\end{align*}\\] Vamos chamar matriz \\(\\mathbf{A}_m\\) de “matriz de malha fechada”. A última equação é uma EDO que não possui entrada, então só tem sentido resolvê-la para uma condição inicial \\(\\mathbf{x}(0)\\) diferente de zero. A condição necessária para que os estados do sistema caminhem para zero em regime permanente é apenas que o sistema em malha fechada seja estável, isto é, todos os autovalores da matriz \\(\\mathbf{A}_m\\) devem ter parte real estritamente negativa. Além de estabilidade, é também desejado que a convergência dos estados para zero seja feita com critérios de velocidade e oscilação específicos do projeto. Isso é equivalente a satisfazer as condições de overshoot, tempo de acomodação e dominância. As condições de projeto são definidas em termos de pólos de malha fechada bem selecionados. Esses pólos determinam um polinômio de malha fechada \\(\\alpha (s)\\). Sendo assim, o problema de regulação é enunciado como: achar a matriz \\(\\mathbf{K}\\), tal que estejam no semi-plano esquerdo todas as raizes da equação: \\[\\begin{align} \\det (s\\mathbf{I-A_m})= \\det (s\\mathbf{I-A+BK})=\\alpha (s) \\end{align}\\] Exemplo Problema de segunda ordem, então: \\(\\mathbf{K} = \\begin{bmatrix} k_1 &amp; k_2\\end{bmatrix}\\). Matriz de malha fechada: \\[\\begin{align} \\mathbf{A-BK} = \\left[\\begin{matrix}0 &amp; 1\\\\- \\omega_{0}^{2} - k_{1} &amp; - k_{2}\\end{matrix}\\right] \\end{align}\\] Polinômio característico de malha fechada: \\[ |s\\mathbf{I-A+BK}| = \\omega_{0}^{2} + k_{1} + k_{2} s + s^{2} \\] Polinômio mônico desejado, com dois polos em \\(-2\\omega_0\\): \\[ \\alpha(s) = 4 \\omega_{0}^{2} + 4 \\omega_{0} s + s^{2} \\] Igualando termo a termo: \\[\\begin{align} k_1 + \\omega_0^2 &amp;= 4\\omega_0^2 \\Rightarrow k_1 = 3\\omega_0^2\\\\ k_2 &amp;= 4\\omega_0 \\end{align}\\] O livro mostra uma simulação da resposta desse sistema para \\(\\omega_0=1\\). Repare que os gráficos mostram, em função do tempo, os dois estados. Note que nenhum dos sinais oscila. Isso porque as características dos pólos que foram alocados são válidas para todos os estados e a saída do sistema. Exercício Ache a forma de controlador do sistema \\[\\begin{align} G(s) = \\frac{20}{(s+1)(s+2)} \\end{align}\\] Depois, projete um controlador de realimentação de estados que posicione os pólos em \\(-3\\pm j5\\) 5.2 Forma canônica de controlador O exemplo anterior ilustra bem a solução do problema de realimentação de estados. Porém, ele é simples demais: Ele é de ordem baixa (2). Na prática, os sistemas podem ser de ordem bem mais elevada -Em um problema de ordem mais alta, o trabalho seria muito maior e a solução desenvolvida, inviável Além disso, em um problema real temos também que nos preocupar com questões numéricas de arredondamento. A primeira forma de lidar com problemas de ordem mais alta é transformar o sistema para forma canônica de controlador. Usar essa forma é vantajoso porque ela simplifica as equações dos ganhos na hora que igualamos os polinômios desejado e de projeto. Isso permite encontrar os ganhos com equações mais simples, geralmente fazendo substituições sucessivas. Normalmente, a forma mais fácil de mudar para a forma de controlador é achando a função de transferência do sistema e usando as regras práticas de inspeção do numerador e denominador. Isso pode ser um pouco trabalhoso para sistemas de ordem elevada. 5.3 Método de Ackermann Uma maneira mais direta e geral de projetar a realimentação de estados é usar o método de Ackerman. Ele consiste de aplicar a expressão: \\[\\begin{align} \\mathbf{K} = \\left[\\begin{array}{ccccc}0&amp;0&amp;\\ldots &amp; 0 &amp; 1\\end{array}\\right]\\mathbf{\\mathcal{C}}^{-1}\\alpha_c(\\mathbf{A}) \\end{align}\\] onde \\(\\mathbf{\\mathcal{C}}\\) é a chamada matriz de controlabilidade do sistema \\[\\begin{align} \\mathbf{\\mathcal{C}} = \\left[\\begin{array}{ccccc}\\mathbf{B}&amp;\\mathbf{AB}&amp;\\ldots &amp; \\mathbf{A}^{n-2}\\mathbf{B} &amp; \\mathbf{A}^{n-1}\\mathbf{B}\\end{array}\\right] \\end{align}\\] e \\(\\alpha_c(\\mathbf{A})\\) é uma matriz construída pela expressão: \\[\\begin{align} \\alpha_c(\\mathbf{A}) = \\mathbf{A}^{n}+\\alpha_1\\mathbf{A}^{n-1}+\\alpha_2\\mathbf{A}^{n-2}+\\ldots++\\alpha_n\\mathbf{I} \\end{align}\\] Note que \\(\\alpha_c(\\mathbf{A})\\) é o polinômio de malha fechado desejado, mas no lugar de \\(s\\) temos a matriz \\(\\mathbf{A}\\) de malha aberta do sistema. Observação: a solução do problema só existe se pudermos inverter a matriz de controlabilidade. Logo, a invertibilidade é condição necessária para o regulação do sistema. Normalmente, o primeiro passo de um projeto de controle é verificar se ele é controlável. O método é trabalhoso, mas fácil de implementar no computador. Em Python temos a função “acker()” da biblioteca control que faz o processo automaticamente (sem precisar fornecer a forma de controlador), que funciona bem para sistemas de até 10a ordem e preferencialmente com pólos de malha fechada não-repetidos. Para problemas mais complexos, recomenda-se o uso da função “place()” da biblioteca control, ou “place_poles()” da biblioteca scipy.signal. Nota: essas funções só funcionam para problemas numéricos. Exemplo: Matriz de controlabilidade: \\[\\begin{align} \\mathcal{{C}} &amp;= \\begin{bmatrix} \\mathbf{B} &amp; | &amp; \\mathbf{AB}&amp; \\end{bmatrix} = \\left[\\begin{matrix}0 &amp; 1\\\\1 &amp; 0\\end{matrix}\\right] \\end{align}\\] Inversa: \\[\\begin{align} \\mathcal{{C}}^{-1} &amp;= \\left[\\begin{matrix}0 &amp; 1\\\\1 &amp; 0\\end{matrix}\\right] \\end{align}\\] Note que, neste caso, a inversa é a própria matriz. Matriz \\(\\mathbf{A}\\) aplicada ao polinômio \\(\\alpha\\): \\[ \\alpha(\\mathbf{A}) = 4\\omega_0^2\\mathbf{I} + 4\\omega_0 \\mathbf{A} + \\mathbf{A}^2 = \\left[\\begin{matrix}3 \\omega_{0}^{2} &amp; 4 \\omega_{0}\\\\- 4 \\omega_{0}^{3} &amp; 3 \\omega_{0}^{2}\\end{matrix}\\right] \\] Fórmula de Ackerman: \\[\\begin{align} \\mathbf{K} = \\begin{bmatrix} 0 &amp; 1 \\end{bmatrix} \\, \\left[\\begin{matrix}0 &amp; 1\\\\1 &amp; 0\\end{matrix}\\right] \\, \\left[\\begin{matrix}3 \\omega_{0}^{2} &amp; 4 \\omega_{0}\\\\- 4 \\omega_{0}^{3} &amp; 3 \\omega_{0}^{2}\\end{matrix}\\right] = \\left[\\begin{matrix}3 \\omega_{0}^{2} &amp; 4 \\omega_{0}\\end{matrix}\\right] \\end{align}\\] Solução numérica com Python: import control as ct import numpy as np w0 = 1 A = np.array([[0, 1],[-w0**2, 0]]) B = np.array([[0],[1]]) polos = [-2*w0, -2*w0] K = ct.acker(A,B, polos) print(K) ## [[3. 4.]] A fórmula de Ackermann permite posicionar os pólos de malha fechada em qualquer lugar desejado, desde que a matriz de controlabilidade possua inversa. Isso torna o projeto mais direto, comparado por exemplo, ao método de projeto com LGR, onde o posicionamento dos pólos com controle proporcional fica restrito ao lugar geométrico. No entanto, isso é possível devido à hipótese forte de que todos os estados estão disponíveis para realimentação. Exercício Use Ackermann para projetar um controlador para o sistema \\[\\begin{align} G(s) &amp;= \\frac{30}{s(s+1)^2} \\end{align}\\] Posicione os pólos em \\(-4\\pm j4\\) e \\(-12\\). 5.4 Introdução da referência Até agora vimos como resolver o problema da regulação de estados apenas para zerar o estado final. No entanto, o objetivo do controle é fazer a saída rastrear a referência \\(r\\). Uma forma simples de fazer isso é usando o sinal de controle: \\[\\begin{align*} u &amp;= -\\mathbf{Kx}+Nr \\end{align*}\\] onde \\(\\mathbf{K}\\) é o vetor de ganhos conforme já definimos e \\(N\\) é um ganho a se determinar. Se usarmos esta lei de controle, a equação de estados do sistema em malha fechada fica: \\[ \\dot{\\mathbf{x}} = \\mathbf{(A-BK)x} + \\mathbf{B}N\\,r \\] A equação de saída fica: \\[ y = (\\mathbf{C}-D\\mathbf{K})\\mathbf{x}+DN\\,r \\] A função de transferência do sistema da entrada de referência \\(r\\) para a saída \\(y\\) é: \\[ G(s) = (\\mathbf{C}-D\\mathbf{K})(s\\mathbf{I-A+BK})^{-1}\\mathbf{B}N+DN \\] Se quisermos que o sistema rastreie a referência em regime permanente, \\(y=r\\), o ganho DC do sistema deve ser unitário, isto é, \\(G(0)=1\\). Então fazemos \\(G(0)=1\\) na equação e resolvemos para \\(N\\). O resultado é: \\[ N = \\frac{1}{(\\mathbf{C}-D\\mathbf{K})(\\mathbf{-A+BK})^{-1}\\mathbf{B}+D} \\] Como normalmente o ganho \\(D\\) é nulo, temos o resultado mais usual: \\[ N = \\frac{1}{\\mathbf{C}(\\mathbf{-A+BK})^{-1}\\mathbf{B}} \\] O algoritmo de projeto é, portanto: Calcule o vetor de ganhos \\(\\mathbf{K}\\) normalmente, conforme as especificações de projeto Use o vetor \\(\\mathbf{K}\\) calculado para determinar \\(N\\) Implemente o algoritmo de controle como: \\(u=-\\mathbf{KX}+Nr\\) Precisamos apenas usar a expressão: \\[ N = \\frac{1}{\\mathbf{C}(\\mathbf{-A+BK})^{-1}\\mathbf{B}} \\] A saída do oscilador é a posição \\(x_1\\), logo \\(\\mathbf{C} = \\begin{bmatrix}1 &amp; 0\\end{bmatrix}\\). Usando o resultado anterior para \\(\\mathbf{K}\\). \\[\\begin{align} \\mathbf{-A+BK} &amp;= \\left[\\begin{matrix}0 &amp; -1\\\\4 \\omega_{0}^{2} &amp; 4 \\omega_{0}\\end{matrix}\\right] \\\\ (\\mathbf{-A+BK})^{-1} &amp;= \\left[\\begin{matrix}\\frac{1}{\\omega_{0}} &amp; \\frac{1}{4 \\omega_{0}^{2}}\\\\-1 &amp; 0\\end{matrix}\\right]\\\\ N &amp;= \\frac{1}{\\mathbf{C}(\\mathbf{-A+BK})^{-1}\\mathbf{B}} &amp;= \\frac{1}{\\frac{1}{4 \\omega_{0}^{2}}} = 4 \\omega_{0}^{2} \\end{align}\\] 5.4.1 Simulação em malha fechada É interessante testar o projeto agora usando uma resposta ao degrau. Note que para isso, precisamos definir o sistema em malha fechada. Substituindo \\(u=-\\mathbf{Kx}+Nr\\) na equação de estados vemos que as matrizes \\(\\mathbf{A}\\) e \\(\\mathbf{B}\\) em malha fechada mudam. A saída permanence a mesma, logo a matriz \\(\\mathbf{C}\\) de malha fechada permanece a mesma. Em malha fechada (i.e., ganhos realimentados), as equações do sistema ficam: \\[\\begin{align} \\mathbf{\\dot{x}} &amp;= \\mathbf{(A-BK)x} +\\mathbf{B}Nr\\\\ y &amp;= \\mathbf{Cx} \\end{align}\\] A seguir resolvemos e simulamos o sistema do exemplo anterior com \\(\\omega_0=1\\). Imports e sistema import control as ct import numpy as np w0 = 1 A = np.array([[0, 1],[-w0**2, 0]]) B = np.array([[0],[1]]) C = np.array([[1,0]]) Alocação de pólos e referência polos = [-2*w0, -2*w0] K = ct.acker(A,B, polos) N = 1/(C @ np.linalg.inv(-A+B@K) @ B) Matrizes de malha fechada. Repare o uso do símbolo @ para produto matricial. Amf = A - B@K Bmf = B@N Cmf = C Dmf = np.array([[0]]) # Sistema sis = ct.ss(Amf,Bmf,Cmf,Dmf) Relatório de pólos de malha fechada tab = ct.damp(sis) ## Eigenvalue (pole) Damping Frequency ## -2 1 2 ## -2 1 2 Os pólos foram corretamente alocados. Repare que, por serem reais, o programa considera amortecimento (damping) igual a 1 e a frequência natural é o módulo do pólo. Zeros de transmissão ct.zeros(sis) ## array([], dtype=complex128) O sistema não possui zeros. Simula o sistema para uma resposta ao degrau unitário. Tempo de simulação é 7 segundos. t,y = ct.step_response(sis,7) Plota os resultados, com algumas legendas import matplotlib.pyplot as plt plt.plot(t,y) plt.grid() plt.xlabel(&#39;Tempo (seg)&#39;) plt.ylabel(&#39;Saída&#39;) plt.legend(&#39;y&#39;) plt.show() 5.5 Escolha dos pólos O sucesso do controle depende da escolha adequada do polinômio de malha fechada desejado. Esse polinômio deve ser construído tendo em mente todos os pólos de malha fechada desejados, não apenas os dominantes. Isso é importante quando temos um sistema de ordem maior que 2: os pólos que não serão dominantes devem ser escolhidos suficientemente distantes dos candidatos a dominantes. Uma regra prática é, após escolher os dominantes, escolher os demais como reais, com a parte real de 3 a 5 vezes maior que a parte real dos dominantes. Lembre-se, porém, que se o deslocamento dos polos para a nova posição for muito grande, os ganhos do controlador vão aumentar e consequentemente o sinal de controle vai exigir mais energia. Outra coisa a se ter em mente na hora de escolher pólos de malha fechada são os zeros do sistema. A realimentação de estados não altera a posição dos zeros, isto é, se eles não forem cancelados, eles permanecerão na mesma posição em malha fechada. Agora, se estes zeros estiverem próximos dos pólos dominantes em malha fechada, a dinâmica projetada não irá funcionar corretamente (normalmente o overshoot será mais alto do que o projetado). Uma forma de lidar com isso é posicionar um pólo extra sobre o zero que está atrapalhando o projeto, mas apenas se o zero for estável. Note que devido às incertezas e os arredondamentos de projeto, podemos ter que fazer novas escolhas de polos até achar uma combinação que se ajuste ao que precisamos. Observe a solução com Python. # Imports import control as ct import numpy as np # Sistema A = np.array([ [0, 2, 0, 0, 0], [-.1, -.35, .1, .1, .75], [0, 0, 0, 2, 0], [.4, .4, -.4, -1.4, 0], [0, -.03, 0, 0, -1] ],dtype=float) B = np.array([[0],[0],[0],[0],[1]]) C = np.array([[1,0,0,0,0]]) D = np.array([[0]]) Pólos desejados, calculados pelos parâmetros físicos xi = 0.707 wn = 1/1.15 p = -xi*wn+1j*wn*np.sqrt(1-xi**2) Polos de malha fechada desejados, conjunto completo. Note a forma de gerar os pólos adicionais usando o dominante como referência e o recurso de repetição de elementos de uma lista. polos_dom = np.array([[p, np.conjugate(p)]]) polos_extras = np.array([[np.real(p)*4]*3]) polos_mf = np.block([polos_dom,polos_extras]) Alocação de polos e referência K = ct.acker(A,B,polos_mf[0,:]) N = 1/(C @ np.linalg.inv(-A+B@K) @ B) O vetor de ganhos encontrado é \\(\\mathbf{K} = \\left[\\begin{matrix}8.1 &amp; 19.33 &amp; 1.27 &amp; -0.2139 &amp; 5.857\\end{matrix}\\right]\\) Os valores são um pouco diferentes do livro. Tente descobrir a razão Simulação em malha fechada: Amf = A - B@K Bmf = B@N Cmf = C Dmf = np.array([[0]]) # Sistema sis = ct.ss(Amf,Bmf,Cmf,Dmf) # Simulação t,y = ct.step_response(sis,7) plt.plot(t,y) plt.grid() plt.xlabel(&#39;Tempo (seg)&#39;) plt.ylabel(&#39;Saída&#39;) plt.legend(&#39;y&#39;) plt.show() É sempre importante analisar as características do sistema (pólos e zeros), além dos sinais. tab = ct.damp(sis) ## Eigenvalue (pole) Damping Frequency ## -2.459 1 2.459 ## -2.459+2.019e-05j 1 2.459 ## -2.459-2.019e-05j 1 2.459 ## -0.6148 +0.615j 0.707 0.8696 ## -0.6148 -0.615j 0.707 0.8696 Zeros: sis.zeros() ## array([-0.7+0.55677644j, -0.7-0.55677644j]) valor máximo de saída: print(max(y)) ## 1.0339565325466082 Tente explicar o que aconteceu com o projeto em malha fechada. Faça correlação com o gráfico do sinal de saída. Exemplo: Abaixo apenas o item (b), resolvendo direto com acker() # Imports import control as ct import numpy as np z0 = 2. # Declaração das matrizes e do sistema A = np.array([[-7,1],[-12,0]]) B = np.array([[1],[-z0]]) C = np.array([[1,0]]) D = np.array([[0]]) sys = ct.ss(A,B,C,D) # Pólos desejados xi = 0.5 wn = 2 polo = wn*(-xi+1j*np.sqrt(1-xi**2)) # Alocação de polos K = ct.acker(A,B,[polo, np.conj(polo)]) Regulador encontrado: \\(\\mathbf{K}= \\left[\\begin{matrix}-3.8 &amp; 0.6\\end{matrix}\\right]\\) Execute novamente o código com \\(z_0=3\\) para verificar a variação dos ganhos como no livro. Espera-se que haja um aumento significativo nos ganhos. Quando um polo e um zero tendem a se cancelar, o sistema tende a perder controlabilidade e isso torna os ganhos mais altos e, consequentemente, o controle fica mais “caro” (puxa mais energia). Vale a observação do livro: “O sistema tem que trabalhar com mais força para conseguir o controle quando a controlabilidade é fraca.” Além disso: “Mover os polos em um longo caminho requer grandes ganhos.” Isso é observado quando um sistema é naturalmente lento e tentamos deixá-lo mais rápido. Isso normalmente resulta em ganhos grandes (em módulo), o que resulta novamente em um controle “caro”. 5.6 Estimadores de estado No assunto anterior vimos que a ação de controle no espaço de estados é proporcional aos estados do sistema. Para isso ser possível de calcular, precisamos ter esses sinais disponíveis. Na prática, uma medição direta dos estados é raramente viável. O número de sensores pode ser grande, o que tornaria o projeto muito caro. Ou simplesmente, os estados não são possíveis de medir. Para contornar a situação usamos um sistema auxiliar, um subsistema do controlador, que é responsável por fornecer uma estimativa dos estados reais. Esse sistema é chamado de estimador ou observador de estados. 5.6.1 Modelagem do observador Vamos supor que os estados reais sejam \\(\\mathbf{x}\\) e a respectiva estimativa seja \\(\\hat{\\mathbf{x}}\\). Idealmente, queremos que \\(\\hat{\\mathbf{x}}\\approx \\mathbf{x}\\). Suponha que o sistema real seja: \\[\\begin{align*} \\dot{\\mathbf{x}} &amp;= \\mathbf{Ax+B}u\\\\ y &amp;= \\mathbf{Cx} + Du \\end{align*}\\] O estimador é um sistema que tenta “imitar” o original, usando uma dinâmica parecida: \\[\\begin{align*} \\dot{\\mathbf{\\hat{x}}} &amp;= \\mathbf{A\\hat{x}+B}u+\\mathbf{L}(y-\\mathbf{C\\hat{x}}) \\end{align*}\\] A interpretação dessa equação é a seguinte: O termo \\(\\mathbf{A\\hat{x}+B}u\\) é uma tentativa de “imitar” a equação original do sistema. O termo \\(\\mathbf{L}(y-\\mathbf{C\\hat{x}})\\) é um fator de correção do anterior. O termo \\(\\mathbf{C\\hat{x}}\\) representa uma estimativa da saída do sistema (é a matriz de saída \\(\\mathbf{C}\\) vezes os estados estimados) O termo \\(y-\\mathbf{C\\hat{x}}\\) representa, portanto, o erro entre a saída real e a saída estimada. O vetor coluna \\(\\mathbf{L}\\) funciona como um ganho proporcional. Assim, vemos que o estimador é um sistema que “imita” a dinâmica do sistema original, porém, ele corrige o erro da dinâmica usando uma parcela proporcional ao erro de estimativa da saída (que é um sinal que nós realmente conseguimos medir). Esse termo de correção é o que faz o estimador funcionar. Projetar o estimador é essencialmente calcular o vetor \\(\\mathbf{L}\\), chamado de ganho do estimador. Se o ganho do estimador for bem projetado, a diferença entre \\(\\mathbf{x}-\\mathbf{\\hat{x}}\\) cairá rapidamente com o tempo. Ou seja, passado um longo tempo (isto é, em regime permanente), \\(\\mathbf{x}\\) e \\(\\mathbf{\\hat{x}}\\) terão os mesmos valores. Matematicamente representamos \\(\\mathbf{x}\\rightarrow \\mathbf{\\hat{x}}\\). A síntese do estimador é feita da seguinte maneira. Seja \\(e = \\mathbf{x}-\\mathbf{\\hat{x}}\\) o erro de estimação entre os estados. Combinando a dinâmica do sistema e do estimador, podemos mostrar que: \\[\\begin{align*} \\dot{\\mathbf{e}} &amp;= \\mathbf{(A-LC)e} \\end{align*}\\] Esse é um sistema autônomo (sem entrada), que só depende das condições iniciais. Ele só possui a matriz de estados, que se for estável, fará com que o estado inicial decaia a zero, qualquer que ele seja. Em outras palavras, mesmo que não conheçamos o estado inicial do sistema para alimentar o estimador, o erro ainda assim irá para zero em regime permanente. Para que isso aconteça, basta que a matriz \\(\\mathbf{(A-LC)}\\) seja estável, isto é, tenha todos os autovalores no SPE. Esse é um problema semelhante ao da regulação de estados. A única diferença é a posição das matrizes. No problema de regulação temos \\(\\mathbf{A-BK}\\). Regulador Estimador Determinar \\(\\mathbf{K}\\) \\(\\mathbf{L}\\) Dimensões \\(1\\times n\\) \\(n\\times 1\\) Equação \\(\\mathbf{F-GK}\\) \\(\\mathbf{F-LH}\\) Devido às semelhanças, podemos usar as mesmas estratégias e funções Python para projetar o estimador. Exemplo: Dados do problema: \\[\\begin{align} \\mathbf{A} &amp;= \\left[\\begin{matrix}0 &amp; 1\\\\- \\omega_{0}^{2} &amp; 0\\end{matrix}\\right]\\\\ \\mathbf{C} &amp;= \\left[\\begin{matrix}1 &amp; 0\\end{matrix}\\right] \\end{align}\\] Observador: \\[\\begin{align} \\mathbf{L} = \\left[\\begin{matrix}l_{1}\\\\l_{2}\\end{matrix}\\right] \\end{align}\\] Polinômio do observador: \\[\\begin{align} s\\mathbf{I}-\\mathbf{A+LC} &amp;= s\\left[\\begin{matrix}1 &amp; 0\\\\0 &amp; 1\\end{matrix}\\right]-\\left[\\begin{matrix}0 &amp; 1\\\\- \\omega_{0}^{2} &amp; 0\\end{matrix}\\right]+\\left[\\begin{matrix}l_{1}\\\\l_{2}\\end{matrix}\\right]\\left[\\begin{matrix}1 &amp; 0\\end{matrix}\\right]= \\\\ &amp;= \\left[\\begin{matrix}s &amp; 0\\\\0 &amp; s\\end{matrix}\\right]-\\left[\\begin{matrix}0 &amp; 1\\\\- \\omega_{0}^{2} &amp; 0\\end{matrix}\\right]+\\left[\\begin{matrix}l_{1} &amp; 0\\\\l_{2} &amp; 0\\end{matrix}\\right] = \\\\ &amp;= \\left[\\begin{matrix}l_{1} + s &amp; -1\\\\\\omega_{0}^{2} + l_{2} &amp; s\\end{matrix}\\right] \\\\ \\end{align}\\] Logo: \\[\\begin{align} |s\\mathbf{I}-\\mathbf{A+LC}| = \\omega_{0}^{2} + l_{1} s + l_{2} + s^{2} \\end{align}\\] Polinômio desejado: \\[\\begin{align} 100 \\omega_{0}^{2} + 20 \\omega_{0} s + s^{2} \\end{align}\\] Igualando termo a termo: \\[\\begin{align} \\omega_{0}^{2} + l_{2} = 100 \\omega_{0}^{2} \\\\ l_{1} = 20 \\omega_{0} \\end{align}\\] Solução: \\[\\begin{align} \\mathbf{L} = \\left[\\begin{matrix}20 \\omega_{0}\\\\99 \\omega_{0}^{2}\\end{matrix}\\right] \\end{align}\\] Solução numérica Se adotarmos \\(\\omega_0=1\\), podemos resolver o mesmo problema usando a função de posicionamento de polos acker(). De fato, isso é possível, porque o problema do observador é muito semelhante ao do regulador, mudando apenas os seguintes parâmetros. * Usamos \\(\\mathbf{F}^T\\) ao invés de \\(\\mathbf{F}\\) * Usamos \\(\\mathbf{H}^T\\) ao invés de \\(\\mathbf{G}\\) * Transpomos o resultado para obter o ganho do observador na forma de vetor coluna # Imports import control as ct # Declara as matrizes w0=1 A = np.array([[0,1],[-w0**2,0]]) C = np.array([[1,0]]) # Posiciona os polos L = ct.acker(A=A.T,B=C.T,poles=[-10*w0,-10*w0]).T Resultado: \\(\\mathbf{L} = \\left[\\begin{matrix}20.0\\\\99.0\\end{matrix}\\right]\\) 5.6.2 Forma canônica de observador Tal como no caso do regulador de estados, há uma forma de espaço de estados para a qual a solução do observador é muito simples. A forma é conhecida como forma canônica de observador. Para deduzi-la procedemos como anteriormente. Desenhamos um diagrama de blocos e extraimos as equações de estados dos integradores. O caso de terceira ordem geral é mostrado na Figura abaixo. A função de transferência correspondente é: \\[\\begin{align*} G(s) = \\frac{b_1s^2+b_2s+b_3}{s^3+a_1s^2+a_2s+a_3} \\end{align*}\\] Note que: Os integradores não estão em série diretamente Entre cada integrador há um somador Apenas a saída (último integrador) é realimentada A realimentação é feita para cada um dos somadores, através dos ganhos do denominador A entrada se conecta a cada um dos somadores, através dos ganhos do numerador A representação de estados é: \\[\\begin{align*} \\mathbf{\\dot{x}} &amp;= \\left[ \\begin{array}{rrr} -a_1 &amp; 1 &amp; 0\\\\ -a_2 &amp; 0 &amp; 1\\\\ -a_3 &amp; 0 &amp; 0\\end{array} \\right]\\mathbf{{x}}+ \\left[\\begin{array}{rrr} b_1\\\\ b_2\\\\ b_3\\end{array} \\right]u\\\\ y &amp;= \\left[\\begin{array}{ccc} 1 &amp; 0 &amp; 0\\end{array}\\right]\\mathbf{x} \\end{align*}\\] Note que: * Na matriz \\(\\mathbf{A}\\), a primeira coluna é formada pelos coeficientes do denominador com sinal trocado, ordem crescente de potência de \\(s\\), de cima para baixo. * As colunas restantes podem ser montadas usando uma matriz identidade de ordem 2 e uma linha de zeros * A matriz \\(\\mathbf{B}\\) é uma coluna formada pelos coeficientes do numerador, ordem crescente de potência de \\(s\\) de cima para baixo. * A matriz \\(\\mathbf{C}\\) é uma linha de zeros, exceto pelo primeiro elemento igual a 1. * \\(J=0\\). Exercício: Desenhe e obtenha as matrizes para o caso de 4a ordem. A forma de observador é útil no projeto de observadores. Para o caso de 3a ordem anterior, a matriz de projeto é \\[\\begin{align*} \\mathbf{A-LC} &amp;= \\left[ \\begin{array}{rrr} -a_1-l_1 &amp; 1 &amp; 0\\\\ -a_2-l_2 &amp; 0 &amp; 1\\\\ -a_3-l_3 &amp; 0 &amp; 0\\end{array} \\right] \\end{align*}\\] cuja equação característica é: \\[\\begin{align*} s^3+(a_1+l_1)s^2+(a_2+l_2)s+(a_3+l_3)=0 \\end{align*}\\] Assim, podemos achar os ganhos do observador \\(\\mathbf{L}=\\left[\\begin{array}{ccc} l_1 &amp; l_2 &amp; l_3\\end{array} \\right]\\) muito facilmente com o polinômio desejado. 5.6.3 Observabilidade Observabilidade é a capacidade que um sistema possui em “permitir” que seus estados sejam estimados a partir apenas do conhecimento do sinal de saída. Da mesma forma que a controlabilidade, podemos medir a observabilidade pela matriz de observabilidade e seu determinante. A matriz de observabilidade é construída linha por linha, como: \\[\\begin{align*} \\mathbf{\\mathcal{O}} &amp;= \\left[ \\begin{array}{c} \\mathbf{C}\\\\ \\mathbf{CA}\\\\ \\mathbf{CA^2}\\\\ \\vdots\\\\ \\mathbf{CA^{n-1}} \\end{array} \\right] \\end{align*}\\] Uma forma rápida de calcular essa matriz é usar a função obsv() da biblioteca control. Um sistema SISO é observável se \\(\\det \\mathbf{\\mathcal{O}} \\neq 0\\). Se o sistema é MIMO, devemos olhar para o posto da matriz de observabilidade. O sistema perde observabilidade quando há cancelamentos entre pólos zeros, de forma semalhante à controlabilidade. O sistema torna-se mais observável à medida que possui mais saídas mensuráveis. Observe que existem diversos paralelos entre controlabilidade e observabilidade, inclusive nos cálculos. Como já mostramos, os cálculos de observabilidades basicamente trocam a matriz \\(\\mathbf{B}\\) pela transposta de \\(\\mathbf{C}\\) e a matriz de estados pela sua transposta. Esse “paralelismo” é chamado de dualidade entre as duas propriedades. 5.7 Compensador dinâmico Já aprendemos a projetar um regulador, que é um conjunto de ganhos que calcula a ação de controle usando os estados do sistema. Também aprendemos a projetar um observador de estados, que é um sistema dinâmico cuja função é fornecer uma estimativa dos estados reais do sistema a partir do sinal de saída. O compensador dinâmico é a junção destas duas ideias no mesmo sistema. A Figura abaixo esquematiza todos os subsistemas e rotas de sinal com a estratégia adotada. No final, nosso controlador projetado com essas abordagens é um único sistema, cujas equações de estado são: \\[\\begin{align*} \\dot{\\mathbf{x}}_e &amp;= \\mathbf{(A-BK-LC)}\\mathbf{x}_e+\\mathbf{L}y\\\\ u &amp;= \\mathbf{-K}\\mathbf{x}_e \\end{align*}\\] onde \\(\\mathbf{x}_e\\) é a estimativa dos estados do sistema pelo observador, \\(\\mathbf{K}\\) e \\(\\mathbf{L}\\) são respectivamente os ganhos do regulador e do observador. Note que a entrada do controlador é a saída da planta. Da mesma forma, o sinal de saída do controlador é o sinal de controle \\(u\\), que vai para a entrada da planta. Perceba, que estas duas equações permitem realizar o controlador como um sistema entrada-saída normal, com uma função de transferência que basicamente dispensa as equações de estado, para fins de implementação. Esta função é: \\[\\begin{align*} Q(s) &amp;= -\\mathbf{K}(s\\mathbf{I-A+BK+LC})^{-1}\\mathbf{L} \\end{align*}\\] Para fins de simulação, o sistema completo (planta+controlador) podem ser simulados usando um único conjunto de equações de estados: \\[\\begin{align*} \\dot{\\mathbf{x}} &amp;= \\mathbf{A}\\mathbf{x}-\\mathbf{BK}\\mathbf{x_e}\\\\ \\dot{\\mathbf{x}}_e &amp;= \\mathbf{(A-BK-LC)}\\mathbf{x}_e+\\mathbf{LCx}\\\\ y&amp;= \\mathbf{Cx} \\end{align*}\\] É possível demonstrar que os pólos de malha fechada compensado por um controlador dessa natureza são exatamente os pólos projetados pelo regulador de estados completo (isto é, considerando realimentação dos estados verdadeiros, mesmo que na prática não vá ser assim no final) e o pólos alocados para o observador. Em outras palavras, o polinômio de malha fechada quando usamos um compensador que combina regulador+observador é simplesmente: \\[\\begin{align*} \\alpha_{\\text{mf}}(s) = \\alpha_{\\text{reg}}(s)\\cdot \\alpha_{\\text{obs}}(s) \\end{align*}\\] onde “mf”, “reg” e “obs” indicam respectivamente “malha fechada”, “regulador” e “observador”. O fato do projeto dos dois sistemas não “misturar” os pólos é um fato notável, que permite que os projetos sejam feitos de forma independente. Isso é chamado de principío da separação em teoria de controle. 5.7.1 Compensador com referência Considerando a entrada \\(u = Nr - \\mathbf{K}\\mathbf{x}_e\\) e um sistema com \\(D=0\\), as equações de estado ficam: \\[\\begin{align} \\dot{\\mathbf{x}} &amp;= \\mathbf{Ax}-\\mathbf{BK}\\mathbf{x}_e +\\mathbf{B}Nr\\\\ \\dot{\\mathbf{x}}_e &amp;= \\mathbf{(A-BK-LC)}\\mathbf{x}_e+\\mathbf{L}y +\\mathbf{B}Nr\\\\ y &amp;= \\mathbf{Cx} \\end{align}\\] Para fins de simulação, é interessante blocar as matrizes para termos uma única representação global em malha fechada e podermos simular. \\[\\begin{align} \\begin{bmatrix}\\dot{\\mathbf{x}}\\\\\\dot{\\mathbf{x}}_e\\end{bmatrix} &amp;= \\begin{bmatrix} \\mathbf{A} &amp; \\mathbf{-BK} \\\\ \\mathbf{LC} &amp; \\mathbf{A-BK-LC}\\end{bmatrix} \\begin{bmatrix} {\\mathbf{x}}\\\\{\\mathbf{x}}_e\\end{bmatrix} + \\begin{bmatrix}\\mathbf{B}N \\\\ \\mathbf{B}N\\end{bmatrix}r\\\\ y &amp;= \\begin{bmatrix}\\mathbf{C} &amp; \\mathbf{0}\\end{bmatrix}\\begin{bmatrix} {\\mathbf{x}}\\\\{\\mathbf{x}}_e\\end{bmatrix} \\end{align}\\] Com essas matrizes também podemos calcular o valor do ganho de referência \\(N\\) a fim de fornecer erro de regime nulo para uma entrada degrau, da mesma forma que já foi explicado, porém usando as matrizes blocadas. Imports # Imports import control as ct import numpy as np Declaração das matrizes e do sistema A = np.array([[0,1],[0,0]]) B = np.array([[0],[1]]) C = np.array([[1,0]]) D = np.array([[0]]) sys = ct.ss(A,B,C,D) Controlabilidade Co= ct.ctrb(A,B) A matriz de controlabilidade é \\[ \\mathcal{C} = \\left[\\begin{matrix}0 &amp; 1.0\\\\1.0 &amp; 0\\end{matrix}\\right] \\] O determinante é \\(-1.0\\), logo o sistema é controlável. Observabilidade Ob= ct.obsv(A,C) A matriz de observabilidade é \\[ \\mathcal{O} = \\left[\\begin{matrix}1.0 &amp; 0\\\\0 &amp; 1.0\\end{matrix}\\right] \\] O determinante é \\(1.0\\), logo o sistema é observável Pólos do regulador: xi = 0.707 wn = 1 p = wn*(-xi+1j*np.sqrt(1-xi**2)) pr = [p, np.conj(p)] Cálculo do regulador K = ct.acker(A,B,pr) \\[ \\mathbf{K} = \\left[\\begin{matrix}1.0 &amp; 1.414\\end{matrix}\\right] \\] Pólos do observador: xi = 0.5 wn = 5 p = wn*(-xi+1j*np.sqrt(1-xi**2)) po = [p, np.conj(p)] Cálculo do observador L = ct.acker(A.T,C.T,po).T \\[ \\mathbf{L} = \\left[\\begin{matrix}5.0\\\\25.0\\end{matrix}\\right] \\] Função de transferência do controlador: comp = ct.ss(A-B@K-L@C, L, -K,0) Qs = ct.tf(comp) \\[ Q(s) = \\frac{- 40.35 s - 25.0}{1.0 s^{2} + 6.414 s + 33.07} \\] Matrizes em bloco para o sistema em malha fechada: Amf = np.block([[A, -B@K],[L@C, A-B@K-L@C]]) Bmf = np.block([[B],[B]]) Cmf = np.block([[C, np.zeros(C.shape)]]) Cálculo do ganho de referência: N = 1/(Cmf @ np.linalg.inv(-Amf) @ Bmf) Redefinir a matriz \\(\\mathbf{B}\\) de malha fechada para introduzir o ganho \\(N\\) Bmf = Bmf @ N Definie o sistema em malha fechada sis_mf = ct.ss(Amf,Bmf,Cmf, 0) Simula em malha fechada out = ct.step_response(sis_mf) Plota: plt.plot(out.t,out.outputs) plt.grid() plt.xlabel(&#39;Tempo (seg)&#39;) plt.ylabel(&#39;Saída&#39;) plt.legend(&#39;y&#39;) plt.show() 5.8 Controle integral Sabemos que um integrador em malha aberta zera o erro de regime permanente quando fechamos a malha (para uma referência degrau pelo menos) e permite ao sistema rejeitar distúrbios (do tipo degrau). Portanto, a introdução de integradores na malha aberta é um aspecto desejável do projeto. Para introduzir um integrador no espaço de estados, adicionamos um novo estado ao sistema, que representa a integral do erro à referência: \\[\\begin{align*} {e} = \\int (r-y)dt \\end{align*}\\] Supondo que \\(y=\\mathbf{Cx}\\), a equação de estado deste novo sinal é: \\[\\begin{align*} \\dot{e} = r-\\mathbf{Cx} \\end{align*}\\] Essa última equação aumenta a ordem do sistema em 1. O sistema em malha aberta agora fica: \\[\\begin{align*} \\dot{\\mathbf{x}} &amp;= \\mathbf{Ax}+\\mathbf{B}u\\\\ \\dot{e} &amp;= r-\\mathbf{Cx} \\end{align*}\\] Em notação matricial em blocos temos: \\[\\begin{align*} \\left[\\begin{array}{c}\\dot{\\mathbf{x}}\\\\ \\dot{e}\\end{array}\\right]&amp;= \\left[\\begin{array}{cc}\\mathbf{A} &amp; \\mathbf{0}\\\\-\\mathbf{C} &amp; 0\\end{array}\\right]\\left[\\begin{array}{c}{\\mathbf{x}}\\\\ {e}\\end{array}\\right]+\\left[\\begin{array}{c}\\mathbf{B}\\\\ 0\\end{array}\\right]u+\\left[\\begin{array}{c}\\mathbf{0}\\\\ 1\\end{array}\\right]r \\end{align*}\\] Dizemos que o sistema está aumentado O algoritmo de controle integral consiste em fazer uma realimentação completa de todos os estados agora definidos. \\[\\begin{align*} u = -\\mathbf{K}_a\\mathbf{x}_a \\end{align*}\\] Algoritmo de projeto: Construa as matrizes aumentadas: \\[\\begin{align*} \\mathbf{A}_a &amp;= \\left[\\begin{array}{cc}\\mathbf{A} &amp; \\mathbf{0}\\\\-\\mathbf{C} &amp; 0\\end{array}\\right]\\\\ \\mathbf{B}_a &amp;=\\left[\\begin{array}{c}\\mathbf{B}\\\\ 0\\end{array}\\right] \\end{align*}\\] Resolva o problema de regulação com \\((\\mathbf{A}_a, \\, \\mathbf{B}_a)\\), para encontrar a matriz de ganhos aumentada \\(\\mathbf{K}_a\\) 5.8.1 Escolha dos pólos Perceba que a introdução de um integrador aumenta a ordem do sistema e isso vai requerer a especificação de pólos adicionais. Tente alocar estes pólos em posições estratégicas para não comprometer a dominância dos pólos desejados. 5.8.2 Equações de estado do compensador: No controle integral, projetamos o observador de estados normalmente, como se o integrador não estivesse presente. Supondo que os estados do observador são \\(\\mathbf{z}=\\hat{\\mathbf{x}}\\), as equações do compensador serão: \\[\\begin{align*} \\dot{\\mathbf{z}}&amp;= (\\mathbf{A}&#39;-\\mathbf{B}&#39;\\mathbf{K}_a-\\mathbf{L}_0\\mathbf{C}&#39;)\\mathbf{z}+\\mathbf{L}_1y+\\mathbf{M}r\\\\ u &amp;= \\mathbf{-K}_a\\mathbf{z} \\end{align*}\\] As matrizes aumentadas são: \\[\\begin{align} \\mathbf{A}&#39; &amp;= \\left[\\begin{array}{ll} \\mathbf{A} &amp; \\mathbf{0}_{n\\times 1}\\\\ \\mathbf{0}_{1\\times n} &amp; 0 \\end{array}\\right]\\\\ \\mathbf{B}&#39; &amp;= \\left[\\begin{array}{cc} \\mathbf{B} \\\\ {0} \\end{array}\\right]\\\\ \\mathbf{C}&#39; &amp;= \\left[\\begin{array}{cc} \\mathbf{C} &amp; {0} \\end{array}\\right]\\\\ \\mathbf{L}_0 &amp;= \\left[\\begin{array}{cc} \\mathbf{L} \\\\ {0} \\end{array}\\right]\\\\ \\mathbf{L}_1 &amp;= \\left[\\begin{array}{rr} \\mathbf{L} \\\\ {-1} \\end{array}\\right]\\\\ \\mathbf{M} &amp;= \\left[\\begin{array}{cc} \\mathbf{0}_{n\\times 1} \\\\ 1 \\end{array}\\right] \\end{align}\\] É interessante observar que esse compensador requer duas entradas distintas para ser realizado: a referência e a saída da planta. Lembre-se que do ponto de vista do controlador, a saída é o sinal de controle \\(u\\). Portanto, a saída da planta \\(y\\) é vista por ele como uma entrada, assim como a referência \\(r\\). Podemos enxergá-lo através de duas funções de transferência: uma de \\(Y\\) para \\(U\\) e outra de \\(R\\) para \\(U\\). Assim, a saída do controlador poderia ser descrita como: \\[\\begin{align} U(s) = C_1(s)Y(s)+C_2(s)R(s) \\end{align}\\] As funções de transferência \\(C_1(s)\\) e \\(C_2(s)\\) podem ser calculadas pelas matrizes usando a expressão que já estudamos. Do ponto de vista de fluxo de sinal, o sistema controlador funciona conforme o diagrama de blocos a seguir Figure 5.1: Controle integral Esse diagrama pode ser modificado para utilizar a estrutura convencional de controle com realimentação unitária, mas nesse caso, o bloco que alimenta a referência sofre modificação (desafio: verifique que diagrama é esse) 5.8.3 Simulação em malha fechada Com a realimentação do sistema aumentado, as equações em malha fechada serão: \\[\\begin{align*} \\dot{\\mathbf{x}} &amp;= \\mathbf{A}\\mathbf{x}-\\mathbf{B}\\mathbf{K}_a\\mathbf{z}\\\\ \\dot{\\mathbf{z}} &amp;= (\\mathbf{A&#39;}-\\mathbf{B&#39;}\\mathbf{K}_a-\\mathbf{L}_0\\mathbf{C}&#39;)\\mathbf{z}+\\mathbf{L}_1\\mathbf{C}\\mathbf{x}+\\mathbf{M}\\, r\\\\ y&amp;= \\mathbf{Cx} \\end{align*}\\] Matrizes de malha fechada: \\[\\begin{align} \\mathbf{A}_{\\text{mf}} &amp;= \\left[\\begin{array}{cc} \\mathbf{A} &amp; -\\mathbf{B}\\mathbf{K}_a\\\\ \\mathbf{L}_1\\mathbf{C} &amp; \\mathbf{A}&#39;-\\mathbf{B}&#39;\\mathbf{K}_a-\\mathbf{L}_0\\mathbf{C}&#39; \\end{array}\\right]\\\\ \\mathbf{B}_{\\text{mf}} &amp;= \\left[\\begin{array}{cc} \\mathbf{0}_{n\\times 1} \\\\ \\mathbf{M} \\end{array}\\right] = \\left[\\begin{array}{cc} \\mathbf{0}_{2n\\times 1} \\\\ 1 \\end{array}\\right]\\\\ \\mathbf{C}_{\\text{mf}} &amp;= \\left[\\begin{array}{cc} \\mathbf{C} &amp; \\mathbf{0}_{1\\times (n+1)} \\end{array}\\right]\\\\ \\mathbf{D}_{\\text{mf}} &amp;= 0 \\end{align}\\] Perceba que a realimentação de estados é feita através do sinal \\(u\\). O sinal \\(r\\), de referência não deve ser usado para realimentar. Exemplo: Construa um compensador com controle integral para o sistema \\[\\begin{align} G(s) = \\frac{10}{(s+1)(s+2)} \\end{align}\\] para que \\(\\xi = 0.7\\) e \\(\\omega_n=2\\). Imports Declara o sistema A = np.array([[-3,-2],[1,0]]) B = np.array([[1],[0]]) C = np.array([[0,10]]) D = np.array([[0]]) \\[\\begin{align} \\dot{\\mathbf{x}} &amp;= \\left[\\begin{matrix}-3 &amp; -2\\\\1 &amp; 0\\end{matrix}\\right]\\mathbf{x} + \\left[\\begin{matrix}1\\\\0\\end{matrix}\\right]u\\\\ y &amp;= \\left[\\begin{matrix}0 &amp; 10\\end{matrix}\\right]\\mathbf{x} \\end{align}\\] Matrizes aumentadas Aa = np.block([[A, np.zeros([2,1])],[-C, 0]]) Ba = np.block([[B],[0]]) \\[\\begin{align} \\mathbf{A}_a &amp;= \\left[\\begin{matrix}-3.0 &amp; -2.0 &amp; 0\\\\1.0 &amp; 0 &amp; 0\\\\0 &amp; -10.0 &amp; 0\\end{matrix}\\right]\\\\ \\mathbf{B}_a &amp;= \\left[\\begin{matrix}1\\\\0\\\\0\\end{matrix}\\right] \\end{align}\\] Especificações xi = 0.7 wn = 2 # Polos de MF desejados pr = wn*(-xi+1j*np.sqrt(1-xi**2)) Pólos desejados: \\[ s = -1.4 \\pm j 1.4283 \\] Como o projeto ficou de terceira ordem, precisamos completar com um pólo. Para não interferir na dominância, vamos alocá-lo com uma frequência natural 5 vezes maior. Assim, o pólo extra será \\(s=-10\\). p = [pr, np.conj(pr), -5*abs(pr)] Projeto do ganho aumentado com Ackermann Ka = ct.acker(Aa,Ba,p) \\[\\begin{align} \\mathbf{K}_a = \\left[\\begin{matrix}9.8 &amp; 30.0 &amp; -4.0\\end{matrix}\\right] \\end{align}\\] Note que: \\[\\begin{align} \\mahtbf{K} &amp;= \\left[\\begin{matrix}9.8 &amp; 30.0\\end{matrix}\\right]\\\\ K_i &amp;= -4.0 \\end{align}\\] Para o projeto do observador, podemos usar pólos distantes em um fator de 10 dos pólos originais. po = [10*pr, 10*np.conj(pr)] Projeto do observador L = ct.acker(A.T, C.T, po).T \\[\\begin{align} \\mathbf{L} = \\left[\\begin{matrix}32.3\\\\2.5\\end{matrix}\\right] \\end{align}\\] Vamos agora escrever as equações de estado do controlador. Matrizes auxiliares: n = 2 Al = np.block([[A,np.zeros((n,1))],[np.zeros((1,n+1))]]) Bl = Ba Cl = np.block([C,0]) L0 = np.block([[L],[0]]) L1 = np.block([[L],[-1]]) M = np.block([[np.zeros((n,1))],[1]]) Matrizes do controlador Ac = np.block([[A-B@K-L@C, -B*Ki], [np.zeros((1,3))]]) B1 = np.block([[L],[-1]]) B2 = np.block([[np.zeros((2,1))],[-1]]) Cc = np.block([-K, -Ki]) D1 = np.array([[0]]) D2 = D1 Equações do controlador: \\[\\begin{align} \\dot{\\mathbf{z}} &amp;= \\left[\\begin{matrix}-12.8 &amp; -355.0 &amp; 4.0\\\\1.0 &amp; -25.0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{matrix}\\right] \\mathbf{z} + \\left[\\begin{matrix}32.3\\\\2.5\\\\-1.0\\end{matrix}\\right] y\\\\ u &amp;= \\left[\\begin{matrix}-9.8 &amp; -30.0 &amp; 4.0\\end{matrix}\\right] \\mathbf{z} \\end{align}\\] Funções de transferência do controlador. Primeiro, da saída do sistema \\(y\\) para o sinal de controle \\(u\\). C1 = ct.ss(Ac, B1, Cc, D1) C1 = ct.tf(C1) Atenção ao índice utilizado para a matriz Bc. \\[\\begin{align} C_1(s) &amp;= \\frac{- 395.54 s^{2} - 1257.0 s - 1600.0}{1.0 s^{3} + 37.8 s^{2} + 675.0 s} \\end{align}\\] Depois, a função entre o sinal de controle e a referência: C2 = ct.ss(Ac, B2, Cc, D2) C2 = ct.tf(C2) \\[\\begin{align} C_2(s) &amp;= \\frac{- 4.0 s^{2} - 112.0 s - 1600.0}{1.0 s^{3} + 37.8 s^{2} + 675.0 s} \\end{align}\\] Pólos e zeros do controlador: C1.poles() ## array([-18.9+17.82666542j, -18.9-17.82666542j, 0. +0.j ]) C1.zeros() ## array([-1.58896698+1.23299912j, -1.58896698-1.23299912j]) C2.zeros() ## array([-14.+14.28285686j, -14.-14.28285686j]) Para verificar o projeto, montamos um sistema em malha fechada e simulamos uma referência degrau. Matrizes em malha fechada: Amf = np.block([[A , -B@Ka ] , [ L1@C , Al-Bl@Ka-L0@Cl ] ]) Bmf = np.block([[np.zeros(B.shape)],[M]]) Cmf = np.block([C, np.zeros([1,3])]) Dmf = 0 Sistema e simulação sis_mf = ct.ss(Amf,Bmf,Cmf,Dmf) resp = ct.step_response(sis_mf) Gráficos plt.plot(resp.t, resp.outputs) plt.grid() plt.xlabel(&#39;Tempo (seg)&#39;) plt.show() É sempre prudente analisar a resposta também em termos de pólos e zeros de malha fechada. Isso é especialmente útil quando a simulação parece não exibir o comportamento que foi solicitado no projeto. tabela = ct.damp(sis_mf) ## Eigenvalue (pole) Damping Frequency ## -14 +14.28j 0.7 20 ## -14 -14.28j 0.7 20 ## -10 1 10 ## -1.4 +1.428j 0.7 2 ## -1.4 -1.428j 0.7 2 sis_mf.zeros() ## array([-14.+14.28285686j, -14.-14.28285686j]) Devemos analisar este resultado buscando possíveis cancelamentos entre pólos e zeros. Observe também que a planta não possui zeros. Os zeros que surgem na malha são provenientes do próprio controlador. Também podemos calcular a resposta de malha fechada pelas funções de transferência. Função de malha fechada. G = ct.tf(10, np.poly([-1, -2])) MF = ct.series(C2,ct.feedback(G,C1,1)) Pólos de malha fechada; amortecimento e frequência natural. tabela = ct.damp(MF) ## Eigenvalue (pole) Damping Frequency ## -18.9 +17.83j 0.7275 25.98 ## -18.9 -17.83j 0.7275 25.98 ## -14 +14.28j 0.7 20 ## -14 -14.28j 0.7 20 ## -10 1 10 ## -1.4 +1.428j 0.7 2 ## -1.4 -1.428j 0.7 2 ## 0 1 0 ## ## C:\\Users\\rafae\\AppData\\Local\\Programs\\Python\\PYTHON~1\\Lib\\site-packages\\control\\lti.py:118: RuntimeWarning: invalid value encountered in divide ## zeta = -real(splane_poles)/wn Zeros de malha. MF.zeros() ## array([-18.9+17.82666542j, -18.9-17.82666542j, -14. +14.28285686j, ## -14. -14.28285686j, 0. +0.j ]) A simulação com função de transferência deve fornecer o mesmo resultado. Sistema e simulação resp = ct.step_response(MF) Gráficos plt.plot(resp.t, resp.outputs) plt.grid() plt.xlabel(&#39;Tempo (seg)&#39;) plt.show() Podemos simular uma perturbação no sistema, adicionando um sinal de entrada novo. Na representação de estados isso pode ser feito adicionando uma nova coluna na matriz \\(\\mathbf{B}\\) de malha fechada. A simulação mostra a ação do controle integral, fazendo o sistema retornar ao setpoint. Note que isso não aconteceria se a mesma perturbação fosse aplicada em um sistema sem controle integral. "],["controle-digital.html", "Capítulo 6 Controle Digital 6.1 Amostras 6.2 Conversor A/D 6.3 Período de amostragem 6.4 Sistemas de controle digital", " Capítulo 6 Controle Digital No cenário atual onde os computadores digitais estão presentes em todos os aspectos das nossas vidas, não é estranho que microprocessadores sejam usados também em sistemas de controle automático. Neste capítulo vamos estudar de uma forma geral como isso pode ser feito. 6.1 Amostras A principal diferença entre o controle analógico com o qual temos trabalhado e o controle digital feito por microprocessadores é que os sinais passam a ser amostrados ou discretos. Um sinal é discreto quando os únicos valores que importam são aqueles que ocorrem em um instante de tempo específico. Esses instantes denotam um domínio discreto, normalmente são múltiplos inteiros de uma constante real. Função contínua: \\(x(t)=\\cos (2\\pi t)\\). \\(t\\) pode assumir qualquer valor real. Função ou sinal discreto: \\(x[k] = \\cos(0.2\\pi k )\\). \\(k\\) só pode assumir valores inteiros. \\(k=0\\), \\(\\pm 1\\), \\(\\pm 2\\), \\(\\ldots\\). Essa distinção é necessária porque os computadores digitais trabalham de forma síncrona e discreta: as tarefas só são realizadas em instantes específicos de tempo, que são cronometrados pelo relógio (clock) do processador: na subida ou na descida do clock. Entre um clock e outro, o computador não executa nenhuma ação e os sinais são “segurados” em um valor constante (ou simplesmente consideramos que seja zero). Graficamente, representamos sinais contínuos por uma linha cheia. Sinais discretos representamos apenas pelos pontos correspondentes às amostras (as linhas verticais são apenas ilustrativas). O gráfico acima representa a função \\(\\cos(2\\pi t)\\) contínua e discretizada. A linha preta cheia é o sinal analógico. Ele existe para qualquer instante de tempo, por exemplo \\(t=\\sqrt{2}\\), \\(t=1/9\\). A função denotada por pontos circulares azuis é a versão discreta da mesma função. Observe que os valores do eixo Y são os mesmos do sinal analógico. Porém, as linhas azuis só ocorrem nos instantes \\(0.1\\), \\(0.2\\), etc. Todos são múltiplos inteiros de \\(0.1\\) segundos. Um sinal discreto é muito mais simples de representar no computador. Basta armazenar as amostras em um vetor. O sinal representado acima foi gerado em Python e consiste das seguintes amostras. 6.2 Conversor A/D O conversor Analógico-Digital (A/D) é um elemento conceitual que converte um sinal contínuo no tempo para um sinal discreto no tempo. Na prática ele é implementado como um circuito de chaveamento: a chave fecha para coletar o sinal e abre até que o próximo clock mande coletar outra amostra. Existe uma variedade grande de conversores A/D. A maioria está disponível em um chip eletrônico convencional que pode ser controlado por um microprocessador. Contudo, o mais comum é despachar o microprocessador e o conversor A/D em um único chip, que na prática é o que chamamos de microcontrolador. Nosso escopo aqui não é discutir os circuitos de conversão, isso fica para as aulas de eletrônica. No entanto, precisamos entender os efeitos dele no sistema de controle. O principal efeito é a discretização do sinal, o que produz atraso na malha de controle. Outro efeito secundário é a introdução de erro na medição, porque a representação digital sempre arredonda valores para que o computador possa fazer as contas. Essa é a discretização de amplitude. Você deve ter aprendido isso em Eletrônica Digital. Ela também é importante, mas neste curso não vamos analisar seus efeitos, porque a maioria dos conversores usam uma resolução elevada (10 bits, pelo menos) e isso normalmente é mais que suficiente para desprezarmos os efeitos na maioria dos processos de controle realimentado. 6.3 Período de amostragem É o menor intervalo de tempo entre uma amostra e outra, supondo que elas sejam coletadas sempre no mesmo intervalo. O inverso do período de amostragem é chamado de taxa de amostragem é medida em amostras por segundo, ou ciclos por segundo, cuja unidade típica é Hertz. \\[ \\begin{align} f = \\frac{1}{T}\\quad\\quad \\text{(Hertz)} \\end{align} \\] Um sistema que coleta uma amostra de um sinal a cada \\(0.001\\) segundos possui período de amostragem de \\(1\\) milissegundo e uma taxa de amostragem de 1 kilo Hertz. Existem sistemas de conversão A/D que trabalham com período de amostragem variável, mas não será o caso que vamos estudar neste curso. Quanto menor o período de amostragem “mais fiel” o sinal amostrado será ao sinal contínuo (isso depende da resolução também). No entanto, quando mais “rápida” essa amostragem é, mais caro o conversor fica, tando economicamente (chips mais rápidos custam mais dinheiro) quanto do ponto de vista de energia, pois circuitos que chaveiam muito esquentam demais. import numpy as np import matplotlib.pyplot as plt t = np.linspace(0,1,100) x = np.cos(2*np.pi*t) T1 = 0.1 k1 = np.arange(10) xs1 = np.cos(2*np.pi*k1*T1) T2 = 0.02 k2 = np.arange(int(1/T2)) xs2 = np.cos(2*np.pi*k2*T2) plt.figure(figsize=(16,5)) plt.plot(t,x,&#39;k&#39;,label=&#39;contínuo&#39;) plt.step(k1*T1,xs1,label=f&#39;T={T1}&#39;) plt.step(k2*T2,xs2,label=f&#39;T={T2}&#39;) plt.xlabel(&#39;Tempo (seg)&#39;) plt.legend() plt.show() Note que o período de amostragem não é necessariamente o clock do processador, porque às vezes o processador trabalha mais rápido do que o nosso sistema precisa. Por exemplo, sistemas de temperatura normalmente são lentos, e não é raro eles terem período de amostagem de 1 ou mais segundos. Para um Arduino, entretanto, cujo clock é 16 MHz, 1 segundo equivale a vários clocks. Tudo isso é controlável pelo projetista. Para “baratear” nosso sistema, então, podemos escolher processadores mais lentos. Mas ele não pode haver exagero. Se ele for lento demais, o conversor A/D não conseguirá “perceber” as mudanças significativas do sinal, ou seja, informação será perdida. Se não tivermos informação, o controle não tem como funcionar. Há um critério matemático que estabelece qual a mínima taxa de amostragem que devemos usar para uma dada situação; é o teorema da amostragem de Shannon-Nyquist. Vamos discutí-lo posteriormente. 6.4 Sistemas de controle digital A figura 8.1 mostra como funciona conceitualmente um sistema de controle digital, em relação a um sistema equivalente analógico. O que está acontecendo? O sinal analógico do sensor \\(y(t)\\) é convertido em um sinal discreto \\(y(kT)\\), através do amostrador e do circuito A/D O sinal de referência é agora um sinal discreto \\(r(kT)\\), gerado dentro do controlador digital. O sinal de controle \\(u(kT)\\) é calculado no programa do controlador através de uma equação de diferenças, e não mais por um circuito analógico O sinal de controle \\(u(kT)\\) é convertido para um sinal analógico \\(u(t)\\) pelo conversor D/A + segurador, antes de ir de volta para a planta. A principal desvantagem do controle digital é o atraso nos sinais devido ao procedimento de amostragem e conversão. A informação entre uma amostra e outra é perdida. Essa perda faz com que o controle trabalhe sempre com uma informação atrasada. Se o controlador digital fosse um circuito analógico, esse atraso seria equivalente a uma perda pura de tempo de aproximadamente \\(T/2\\) library(reticulate) "],["transformada-mathcalz.html", "Capítulo 7 Transformada \\(\\mathcal{Z}\\) 7.1 Transformada \\(\\mathcal{Z}\\) 7.2 Transformadas elementares 7.3 Propriedades 7.4 Transformada \\(\\mathcal{Z}\\) inversa 7.5 Relação entre \\(s\\) e \\(z\\) 7.6 Teorema do valor final 7.7 Exercícios", " Capítulo 7 Transformada \\(\\mathcal{Z}\\) A transformada \\(\\mathcal{Z}\\) é a transformada de Laplace aplicada a sistemas de tempo discreto. Um sinal discreto possui uma e somente uma transformada \\(\\mathcal{Z}\\). Usualmente denotamos: \\[\\begin{align} Y(z) &amp;= \\mathcal{Z}\\{y[k]\\} \\end{align}\\] Ou em notação inversa (semelhante à transformada inversa de Laplace): \\[\\begin{align} y[k] &amp;= \\mathcal{Z}^{-1}\\{y[k]\\} \\end{align}\\] A variável complexa \\(z\\) desempenha papel semelhante à frequência complexa \\(s\\) na transformada de Laplace. Note porém, que \\(z\\) é uma variável contínua, enquanto que o tempo \\(k\\) para sinais discretos é uma variável discreta. A relação entre \\(s\\) e \\(z\\) é dada pela equação fundamental: \\[ z = \\exp(sT) \\] Onde \\(T\\) é o período de amostragem sobre o qual o sinal discreto está submetido. 7.1 Transformada \\(\\mathcal{Z}\\) A transformada \\(\\mathcal{Z}\\) da sequência \\(x[k]\\) é definida como: \\[\\begin{align*} \\mathcal{Z}\\{x[k]\\} = X(z) =\\sum_{k=0}^\\infty x[k]\\,z^{-k} \\end{align*}\\] Sinal discreto: \\(k \\in \\mathbb{Z}\\) \\[\\begin{align*} \\mathcal{Z}\\{f[k-1]\\} = z^{-1}F(z) \\end{align*}\\] Equações de diferenças: \\[\\begin{align*} y[k]&amp;=-a_1y[k-1]-a_2y[k-2]+b_0u[k]+b_1u[k-1]\\\\&amp;+b_2u[k-2] \\end{align*}\\] import numpy as np y = np.zeros((10,)) y[0] = 0 y[1] = 1 for k in np.arange(2,10): y[k] = y[k-1]+y[k-2] print(y) ## [ 0. 1. 1. 2. 3. 5. 8. 13. 21. 34.] Função de transferência discreta: \\[\\begin{align} \\displaystyle\\frac{Y(z)}{U(z)} = \\frac{b_0+b_1z^{-1}+b_2z^{-2}}{1+a_1z^{-1}+a_2z^{-2}} \\end{align}\\] 7.2 Transformadas elementares Para a maioria dos resultados, usamos a fórmula da PG infinita: \\[\\begin{align} 1+q+q^2+q^3+\\ldots = \\frac{1}{1-q} \\end{align}\\] Impulso discreto - \\(\\delta[k]\\) \\[\\begin{align} \\mathcal{Z}\\{\\delta[k]\\} = 1 \\end{align}\\] Códigos Python para desenhar o sinal. Imports: import numpy as np Cria o vetor de tempo e uma função rápida para avaliar o impulso de acordo com o tempo. k = np.arange(-5,10) delta = lambda k: k==0 Plotagem: from matplotlib import pyplot as plt plt.figure(figsize=(16,5)) plt.stem(k,delta(k)) plt.title(&#39;Função impulso discreto&#39;); A função de plotagem “stem” é um pouco melhor para ilustração de sinais discretos. Degrau discreto - \\(u[k]\\) \\[\\begin{align} \\mathcal{Z}\\{u[k]\\} = \\frac{z}{z-1} = \\frac{1}{1-z^{-1}} \\end{align}\\] degrau = lambda k: k&gt;=0 plt.figure(figsize=(16,5)) plt.stem(k,degrau(k)) plt.title(&#39;Função degrau discreto&#39;); Exponencial discreta - \\(a^k\\, u[k]\\) \\[\\begin{align} \\mathcal{Z}\\{a^k\\,u[k]\\} = \\frac{z}{z-a} = \\frac{1}{1-az^{-1}} \\end{align}\\] a = 0.9 k = np.arange(-5,15) expo = lambda k: np.real(a**k * degrau(k)) plt.figure(figsize=(16,5)) plt.stem(k,expo(k), label = f&#39;a={a}&#39;); plt.title(&#39;Exponencial discreta (base &lt; 1) &#39;); plt.legend(); Experimente diferentes valores de \\(a\\) e analise o que acontece. Inclusive valores imaginários. 7.3 Propriedades As propriedades mais importantes da transformada \\(\\mathcal{Z}\\) são basicamente as mesmas da transformada de Laplace: Linearidade \\[\\begin{align} k_1\\,x_1[k] + k_2\\,x_2[k] \\longleftrightarrow k_1\\,X_1(z) + k_2\\,X_2(z) \\end{align}\\] Convolução Essa propriedade é a que permite avaliar a resposta de um sistema LIT discreto a uma entrada. É essencialmente a mesma do domínio contínuo, exceto que precisamos redefinir convolução para sinais discretos. \\[\\begin{align} x[k]*h[k] = \\sum_{n=-\\infty}^{\\infty} x[n]h[k-n] \\longleftrightarrow X(z)H(z) \\end{align}\\] Uma consequência disso é que as regras de diagramas de blocos para sistemas discretos são as mesmas dos sistemas contínuos. Deslocamento e condição inicial \\[\\begin{align} x[k+1] \\longleftrightarrow zX(z)-zx[0] \\end{align}\\] Podemos deduzir outras transformadas não-exponenciais a partir das propriedades. Por exemplo: \\[\\begin{align} \\mathcal{Z}\\{A\\,\\cos(\\omega k)\\} &amp;= \\mathcal{Z}\\left\\{\\frac{Ae^{j\\omega k}}{2}+\\frac{Ae^{-j\\omega k}}{2}\\right\\}\\\\[10pt] &amp;= \\frac{Az}{2(z-e^{j\\omega})}+\\frac{Az}{2(z-e^{-j\\omega})}\\\\ &amp;= \\frac{Az(z-\\cos\\omega)}{z^2+2z\\cos\\omega+1} \\end{align}\\] 7.4 Transformada \\(\\mathcal{Z}\\) inversa Expansão em frações parciais de \\(\\displaystyle\\frac{X(z)}{z} \\longrightarrow x[k]\\). Exemplo: use expansão em fraçõs parciais para determinar a transformada inversa de \\[Y(z) = \\displaystyle\\frac{28(z+1)(z-0.7)}{(z-1)(z-0.9)(z+0.9)}\\] Solução com Python: from scipy.signal import residue import sympy as sp Define o problema. Observe diferentes formas de montar os polinômios z = sp.symbols(&#39;z&#39;) num = 28*np.convolve([1,1],[1,-0.7]) den = np.poly([1, 0.9, -0.9, 0]) Verifique a forma como foi definida \\(Y(z)/z\\) Encontra a expansão com a função “residue”. r,p,k = residue(num,den) Note que este resultado é numérico. Para recuperá-lo no contexto simbólico, pode-se usar o seguinte código (há outras formas de fazê-lo) S = 0 for R,P in zip(r,p): S += R.round(2)*z/(z-P.round(2)) S_str = sp.latex(S) Expansão encontrada: \\[\\begin{align} Y(z) = \\frac{1.46 z}{z + 0.9} - \\frac{65.68 z}{z - 0.9} + \\frac{88.42 z}{z - 1.0} - 24.2 \\end{align}\\] Portanto: \\[\\begin{align*} y[k] &amp;= 1.46(-0.9)^k\\, u[k] - 65.68(0.9)^k\\,u[k]\\\\&amp;\\,+88.42u[k]-24.2\\delta[k] \\end{align*}\\] Usamos a transformada inversa para ter um sentimento qualitativo da resposta do sistema e para explicar o que está acontecendo com a dinâmica. Para efeitos de cálculo mesmo, apenas resolvemos numericamente as equações de diferenças. Para projeto de controle, o ideal é converter a função para equação de diferenças. 7.5 Relação entre \\(s\\) e \\(z\\) \\[\\begin{align} z &amp;= e^{sT} \\end{align}\\] Eixo imaginário \\(\\longrightarrow\\) circunferência unitária SPE/SPD \\(\\longrightarrow\\) interior/exterior do círculo unitário Origem \\(s=0\\) \\(\\longrightarrow\\) \\(z=1\\) Parte real constante \\(\\longrightarrow\\) circunferências Parte imaginária constante \\(\\longrightarrow\\) linhas radiais 7.6 Teorema do valor final \\[\\begin{align} \\lim_{k\\rightarrow \\infty} x[k] = \\lim_{z\\rightarrow 1} (1-z^{-1})\\,X(z) \\end{align}\\] desde que todos os pólos de \\(X(z)\\) estejam dentro do círculo unitário. 7.7 Exercícios Determine a transformada inversa de \\(Y(z)\\) A = randint(2,50) B = (-1)**randint(1)*randint(1,50) C = randint(1,10) Y = A/z + B*z/(C*z-1) Y_str = sp.latex(Y) \\[\\begin{align} Y(z) = \\frac{48 z}{9 z - 1} + \\frac{49}{z} \\end{align}\\] Utilize o código para gerar outros problemas e exercitar. Usando Python, calcule o valor final do sinal cuja transformada \\(\\mathcal{Z}\\) é dada. Demonstre manualmente como esse resultado é calculado. # num = randint(1,100)*sp.prod([z*randint(2,10)-1 for i in range(3)] ) num = sp.expand(num) den = sp.expand(sp.prod([z*randint(2,8)-1 for i in range(4)] ) ) G= num/den G_str = sp.latex(G) \\[\\begin{align} G(z) = \\frac{896 z^{3} - 688 z^{2} + 136 z - 8}{980 z^{4} - 721 z^{3} + 195 z^{2} - 23 z + 1} \\end{align}\\] Deduza a transformada inversa da função \\[\\begin{align} X(z) &amp;= \\frac{(A+jB)z}{z-\\alpha \\,e^{j\\beta}} + \\frac{(A-jB)z}{z-\\alpha \\,e^{-j\\beta}} \\end{align}\\] library(reticulate) "],["análise-dinâmica-de-sistemas-discretos.html", "Capítulo 8 Análise dinâmica de sistemas discretos 8.1 Equações de diferenças 8.2 Função de transferência discreta 8.3 Estabilidade 8.4 Tipo de resposta 8.5 Ganho DC", " Capítulo 8 Análise dinâmica de sistemas discretos 8.1 Equações de diferenças São análogas às equações diferenciais, porém ao invés de derivadas, utiliza deslocamentos de tempo na função de saída, p.ex.: \\(y[k+1]\\), \\(y[k-2]\\). A resposta de uma equação de diferenças é uma sequência de valores que pode ser obtida resolvendo a equação analiticamente ou numericamente (mais fácil). Um exemplo clássico é a equação de Fibonacci: \\(y[k+2] = y[k+1]+y[k]\\), com \\(y[0]=0\\), \\(y[1]=1\\). Experimente calcular. import numpy as np from matplotlib import pyplot as plt y = np.zeros(10) y[0] = 0 y[1] = 1 for k in range(len(y)-2): y[k+2] = y[k+1] + y[k] print(&#39;Sequência de Fibonacci: &#39;, y) ## Sequência de Fibonacci: [ 0. 1. 1. 2. 3. 5. 8. 13. 21. 34.] plt.stem(y); A implementação dessas equações é trivial usando loops (estruturas de repetição) computacionais. É desta forma que implementamos um algoritmo de controle dentro de um programa. Equações de diferenças representativas de sistemas reais podem surgir basicamente de duas formas: (a) Da discretização do sistema contínuo (equivalente discreto) (b) Da identificação do sistema contínuo usando regressão linear (identificação de sistemas) 8.2 Função de transferência discreta O procedimento para encontrar a função de transferência discreta é o mesmo aplicado a equações diferenciais, apenas atentando para a propriedade \\[\\mathcal{Z}\\{y[k+1]\\}=zY(z)\\] ou \\[\\mathcal{Z}\\{y[k-1]\\}=z^{-1}Y(z)\\] Exemplo: \\[\\begin{align} y[k+2] + 10y[k] = 8x[k-1] \\end{align}\\] Aplicando a transformada \\(\\mathcal{Z}\\) \\[\\begin{align} z^2Y(z) + 10Y(z) &amp;=8z^{-1}X(z)\\\\ (z^2+10)Y(z) &amp;= \\frac{8X(z)}{z}\\\\ \\frac{Y(z)}{X(z)} &amp;= \\frac{8}{z(z^2+10)} \\end{align}\\] Da mesma forma que o caso contínuo, definimos para funções de transferência discretas: - Pólos: raízes do denominador - Zeros: raízes do numerador As características dos pólos do sistema definem que tipo de resposta ele vai apresentar. 8.3 Estabilidade O sistema é estável se todos os pólos estão dentro do círculo unitário \\(|z|&lt;1\\) O sistema é instável se um ou mais pólos estão fora do círculo unitário \\(|z|\\geq 1\\) 8.4 Tipo de resposta Sobre amortecida (\\(\\xi&gt;1\\)): pólos reais e distintos Criticamente amortecida (\\(\\xi=1\\)): pólos reais e iguais Sub amortecida (\\(\\xi&lt;1\\)): pólos imaginários conjugados estáveis Oscilatória (senoidal pura): pólos imaginários em cima do círculo \\(|z|=1\\) Alternante (oscila, mas não senoidal): pólos reais negativos Integrador: \\(z=1\\) Simulações para ilustrar. Define pólos no domínio \\(s\\) para nos situarmos s1 = np.array([-1,-5]) s2 = np.array([-1,-1]) s3 = np.array([-1+1j, -1-1j]) s4 = np.array([1j, -1j]) Mapeamos estes pólos para o plano \\(z\\), usando a relação fundamental entre \\(s\\) e \\(z\\). T = 0.1 z1 = np.exp(s1*T) z2 = np.exp(s2*T) z3 = np.exp(s3*T) z4 = np.exp(s4*T) Construímos algumas funções de transferência agora. Repare que usaremos apenas um conjunto de pólos (experimente outros por conta própria) num1 = [1,0,0] num2 = np.poly([.85,0]) den = np.poly(z4) H1 = ct.tf(num1,den,T) H1 = H1/H1.dcgain() # Isto é feito para garantir que o ganho DC será 1 H2 = ct.tf(num2,den,T) H2 = H2/H2.dcgain() As duas funções de transferência foram definidas com zeros ligeiramente diferentes, para ver também sua influência. Relatório de pólos discretos _ = ct.damp(H1) ## Eigenvalue (pole) Damping Frequency ## 0.995 +0.09983j -5.551e-16 1 ## 0.995 -0.09983j -5.551e-16 1 print(ct.zero(H1)) ## [0.+0.j 0.+0.j] Simulação de resposta ao degrau. t,y1 = ct.step_response(H1,10) t,y2 = ct.step_response(H2,10) plt.step(t,y1,&#39;b&#39;,t,y2,&#39;r&#39;); plt.legend([&#39;zeros na origem&#39;,&#39;zero próximo&#39;]); plt.show(); 8.5 Ganho DC Para um sistema contínuo sem pólos na origem, o ganho DC é o valor da função de transferência quando \\(s\\rightarrow 0\\). O ganho DC informa o quanto a saída vai aumentar ou diminuir em relação à entrada, quando esta é um sinal constante. O ganho DC discreto possui a mesma interpretação, mas devido ao mapeamento no plano \\(z\\), ele é definido como o valor da função de transferência quando \\(z\\rightarrow 1\\). Exemplo: \\[G(z) = \\displaystyle \\frac{0.0009(z+1)^2}{z(z-0.9)(z-0.8e^{j0.1})(z-0.8e^{-j0.1})}\\] Como todos os pólos são estáveis: \\[\\begin{align} G(z) &amp;= \\frac{0.0009 \\left(z + 1\\right)^{2}}{z \\left(z - 0.9\\right) \\left(z - 0.8 e^{- 0.1 i}\\right) \\left(z - 0.8 e^{0.1 i}\\right)}\\\\K_{dc} &amp;= \\frac{0.036}{\\left(1 - 0.8 e^{- 0.1 i}\\right) \\left(1 - 0.8 e^{0.1 i}\\right)}\\\\K_{dc} &amp;= 0.750104 \\end{align}\\] Usando o pacote “control” num = 9e-4*np.poly([-1,-1]) den = np.poly([0,0.9,0.8*np.exp(0.1j),0.8*np.exp(-0.1j)]) Gz = ct.tf(num,den,1) # Período de amostragem não foi dado, então usamos 1 print(&#39;Ganho DC: &#39;, Gz.dcgain()) ## Ganho DC: 0.7501041464106208 Simulação para visualizar interepratação física from matplotlib import pyplot as plt t,y = ct.step_response(Gz) degrau = np.ones(t.size) plt.step(t,y,t,degrau); plt.grid() print(y[-1]) ## 0.7501039766960299 Quando o sistema possui um ou mais integradores, o ganho DC é calculado da mesma forma, porém removendo os integradores. A interpretação nesse caso é diferente, por ele mede o erro não mais em relação a um degrau, mas a uma entrada equivalente ao número de integradores (rampa, parábola, etc.) library(reticulate) "],["projeto-usando-equivalentes-discretos.html", "Capítulo 9 Projeto usando equivalentes discretos 9.1 Método de Tustin 9.2 Mapeamento de pólos e zeros 9.3 Converter para equação de diferenças.", " Capítulo 9 Projeto usando equivalentes discretos Objetivo: digitalizar (isto é, obter a equação de diferenças) de um controlador contínuo que já está projetado. O resultado é obtido em duas partes: 1 - Obtem-se uma função de transferência discreta a partir de uma contínua 2 - Converte-se a função discreta em uma equação de diferenças A equação de diferenças pode ser implementada no microcontrolador sem grandes dificuldades. A seguir vemos 2 métodos para fazer a parte (1). 9.1 Método de Tustin Idéia central: tratar a aproximação discreta como integração numérica \\[\\begin{align} u[k] = u[k-1] + \\frac{T}{2}\\left(e[k]+e[k-1]\\right) \\end{align}\\] Transformando: \\[\\begin{align} \\frac{U(z)}{E(z)} = \\frac{T}{2}\\,\\frac{1+z^{-1}}{1-z^{-1}} \\end{align}\\] Equação de mapeamento \\(s\\) para \\(z\\) \\[\\begin{align} s \\longmapsto \\frac{2}{T}\\,\\frac{1-z^{-1}}{1+z^{-1}} = \\frac{2}{T}\\,\\frac{z-1}{z+1} \\end{align}\\] Outra forma de deduzir Série de Taylor: \\(e^{x} \\approx 1 + x\\) Então \\[\\begin{align} z = e^{sT} = \\frac{e^{sT/2}}{e^{-sT/2}} \\approx \\frac{1+sT/2}{1-sT/2} \\end{align}\\] Resolvendo \\(s\\) em função de \\(z\\) resulta na mesma equação. Exemplo 8.1: \\[\\begin{align} D(s) = 10\\,\\frac{s/2+1}{s/10+1} \\end{align}\\] \\(\\omega_s = 25\\cdot \\omega_{BW} =250\\) rad/s. \\(f_s \\approx 40\\) Hz. \\(T =1/40 = 0.025\\) seg. O pacote “control” possui funções especializadas que resolvem facilmente estas contas. No entanto, parece haver algumas diferenças de implementação que produzem resultados ligeiramente diferentes. import control as ct T = 0.025 Ds = 10*ct.tf([1/2,1],[1/10,1]) Dz = ct.c2d(Ds,T,method=&#39;bilinear&#39;) print(&#39;Discreto: &#39;, Dz) ## Discreto: ## 45.56 z - 43.33 ## --------------- ## z - 0.7778 ## ## dt = 0.025 Solução com pacote simbólico import sympy as sp T = 0.025 s,z = sp.symbols([&#39;s&#39;, &#39;z&#39;]) Ds = 10*(s/2+1)/(s/10+1) Dz = Ds.subs(s,(2/T)*(z-1)/(z+1)) Dz = Dz.simplify() str = sp.latex(Dz) \\[ D(z) = \\frac{10 \\cdot \\left(410.0 z - 390.0\\right)}{90.0 z - 70.0} \\] Sempre é bom fazer uma simulação e ver se os resultados são coerentes. Tente melhorar os resultados com o período de amostragem. T = 0.1 Ds = 10*ct.tf([1/2,1],[1/10,1]) Dz = ct.c2d(Ds,T,method=&#39;bilinear&#39;) td,yd = ct.step_response(Dz,0.5) t,y = ct.step_response(Ds,0.5) from matplotlib import pyplot as plt plt.plot(t,y,label=&#39;continuo&#39;); plt.step(td,yd,label=&#39;Tustin&#39;); plt.grid(); plt.legend(); plt.show(); 9.2 Mapeamento de pólos e zeros Calcule um pólo/zero discreto para cada pólo/zero contínuo usando \\(z=e^{sT}\\). Iguale o número de zeros ao de pólos adicionando termos \\((z+1)\\) ao numerador (opcional) Multiplique a função de transferência por um ganho de modo que o ganho DC discreto seja igual ao contínuo. Exemplo 8.2: O controlador encontrado é \\(D(s) = 0.81\\,\\displaystyle\\frac{s+0.2}{s+2}\\). O período de amostragem estabelecido é 1 segundo. O controlador possui um pólo em \\(s=-2\\) e um zero \\(s=-0.2\\). Como o controlador tem o mesmo número de pólos e zeros, então o controlador digital deverá ser da forma: \\[\\begin{align} \\hat{D}(z) &amp;= K \\frac{z-a}{z-b} \\end{align}\\] Cálculo do pólo: \\(b = \\exp(-2\\cdot 1)\\) (resultado será visto em Python) Cálculo do zero: \\(a = \\exp(-0.2\\cdot 1)\\) O ganho digital \\(K\\) é calculado igualando os ganhos DC da FT contínua e discreta, \\(D(0)=\\hat{D}(1)\\). Resolução simbólica import numpy as np import sympy as sp Período de amostragem. Mapeamento dos pólos discretos a partir dos contínuos. T = 1 a = np.exp(-0.2*T).round(4) b = np.exp(-2*T).round(4) Construção das funções contínua e discreta. Ds = 0.81*(s+0.2)/(s+2) K = sp.symbols(&#39;K&#39;) Dz = K*(z-a)/(z-b) Iguala os ganhos DC e estabelece equação final equacao = sp.Eq(Ds.subs(s,0), Dz.subs(z,1)) str = sp.latex(equacao) \\[ 0.081 = 0.209668092980224 K \\] Resolução da equação com o próprio “sympy”. sol = sp.solve(equacao) str = &#39;K = &#39; + sp.latex(sol[0]) Solução do ganho: \\[ K = 0.386324875896305 \\] Retorna à função original para encontrar forma final: Dz = Dz.subs(K,sol[0].round(4)) \\[\\begin{align} D(z) &amp;= \\frac{0.3863 \\left(z - 0.8187\\right)}{z - 0.1353}\\\\D(z) &amp;= \\frac{0.3863 z - 0.3163}{z - 0.1353} \\end{align}\\] Fazer com o módulo “control” é um pouco mais direto. Acompanhe: Ds = 0.81*ct.tf([1,0.2],[1,2]) T = 0.020 a = np.exp(T*Ds.zeros()) b = np.exp(T*Ds.poles()) num = np.poly(a) den = np.poly(b) Dz = ct.tf(num,den,T) Dz = Dz*Ds.dcgain()/Dz.dcgain() print(Dz) ## ## 0.081 z - 0.08068 ## ------------------ ## 0.1018 z - 0.09782 ## ## dt = 0.02 Vamos fazer uma simulação para conferir: t,y = ct.step_response(Ds,1.5) k,yd = ct.step_response(Dz,1.5) plt.plot(t,y,label=&#39;Contínuo&#39;) ## [&lt;matplotlib.lines.Line2D object at 0x000002B053DA1E20&gt;] plt.step(k,yd,label=&#39;Mapeamento&#39;) ## [&lt;matplotlib.lines.Line2D object at 0x000002B053DA3A70&gt;] plt.grid() plt.xlabel(&#39;Tempo (seg)&#39;) ## Text(0.5, 0, &#39;Tempo (seg)&#39;) plt.legend() ## &lt;matplotlib.legend.Legend object at 0x000002B054AA90A0&gt; plt.show() Exemplo um pouco mais complexo: Ache o equivalente por mapeamento da função: \\[ \\begin{align} G(s) &amp;= \\frac{s^2-1}{s(s^2+16)} \\end{align} \\] Utilize \\(T=0.01\\). from numpy import exp, round T = 0.05 polos = [0,4j,-4j] zeros = [-1,1] A = [exp(s*T) for s in polos] B = [exp(s*T) for s in zeros] K1 = sp.symbols(&#39;K_1&#39;) G1 = K1 * sp.prod([z-b for b in B]) / sp.prod([z-a for a in A]) DC1 = sp.simplify(G1*(z-1)).subs(z,1) DC = -1/16 k1 = sp.solve(sp.Eq(DC1,DC))[0] G1 = G1.subs(K1,k1) \\[ G(z) = \\frac{0.9965 \\left(z - 1.051\\right) \\left(z - 0.9512\\right)}{\\left(z - 1.0\\right) \\left(z - 0.9801 - 0.1987 i\\right) \\left(z - 0.9801 + 0.1987 i\\right)} \\] K2 = sp.symbols(&#39;K_2&#39;) G2 = K2 * sp.prod([z-b for b in B]) *(z+1) / sp.prod([z-a for a in A]) DC2 = sp.simplify(G2*(z-1)).subs(z,1) DC = -1/16 k2 = sp.solve(sp.Eq(DC2,DC))[0] G2 = G2.subs(K2,k2) \\[ G(z) = \\frac{0.4982 \\left(z - 1.051\\right) \\left(z - 0.9512\\right) \\left(z + 1.0\\right)}{\\left(z - 1.0\\right) \\left(z - 0.9801 - 0.1987 i\\right) \\left(z - 0.9801 + 0.1987 i\\right)} \\] 9.3 Converter para equação de diferenças. Para converter a função do controlador para uma equação de diferenças, introduzimos os sinais de entrada e saída do controlador, distribuimos os coeficientes da equação depois aplicamos a transformada inversa. Normalmente a equação de diferenças é escrita em termos de atrasos (valores passados), então pode ser conveniente converter a função discreta para potências negativas antes de fazer a transformação. Voltando ao exemplo 8.2: Como o sistema é de ordem (grau do denominador) 1, multiplicamos numerador e denominador por \\(z^{-1}\\). \\[\\begin{align} D(z) &amp;= \\frac{0.3863−0.3162}{−0.1353}\\,\\cdot \\frac{z^{-1}}{z^{-1}}\\\\ &amp;= \\frac{0.3863−0.3162z^{-1}}{1−0.1353z^{-1}} \\end{align}\\] Introduzimos os sinais de entrada \\(E(z)\\) (erro) e saída \\(U(z)\\) (ação de controle) na equação e distribuimos. \\[\\begin{align} \\frac{U(z)}{E(z)}&amp;= \\frac{0.3863−0.3162z^{-1}}{1−0.1353z^{-1}}\\\\ (1−0.1353z^{-1})\\,U(z) &amp;= (0.3863−0.3162z^{-1}) E(z)\\\\ U(z) &amp;= 0.1353z^{-1}U(z) + 0.3863E(z)−0.3162z^{-1}E(z) \\end{align}\\] Aplicando a transformada inversa e a propriedade do atraso temos a equação que implementa o controlador: \\[\\begin{align} u[k] &amp;= 0.1353u[k-1] + 0.3863e[k]−0.3162e[k-1] \\end{align}\\] "]]
